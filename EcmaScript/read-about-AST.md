# 理解作用域
我们学习作用域的方式是将这个过程模拟成几个人物之间的对话。 那么， 由谁进行这场对话呢？

* #### 引擎
从头到尾负责整个 JavaScript 程序的编译及执行过程。

* #### 编译器
引擎的好朋友之一， 负责语法分析及代码生成等脏活累活（详见前一节的内容）。

* #### 作用域
引擎的另一位好朋友， 负责收集并维护由所有声明的标识符（变量） 组成的一系列查询， 并实施一套非常严格的规则， 确定当前执行的代码对这些标识符的访问权限。

## var a = 2 编译步骤
下面我们将 var a = 2; 分解， 看看引擎和它的朋友们是如何协同工作的。编译器首先会将这段程序分解成词法单元， 然后将词法单元解析成一个树结构。 但是当编译器开始进行代码生成时， 它对这段程序的处理方式会和预期的有所不同。
可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量分配内存， 将其命名为 a， 然后将值 2 保存进这个变量。” 然而， 这并不完全正确。事实上编译器会进行如下处理。

1. 遇到 var a， 编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。 如果是， 编译器会忽略该声明， 继续进行编译； 否则它会要求作用域在当前作用域的集合中声明一个新的变量， 并命名为 a。

2. 接下来编译器会为引擎生成运行时所需的代码， 这些代码被用来处理 a = 2 这个赋值操作。 引擎运行时会首先询问作用域， 在当前的作用域集合中是否存在一个叫作 a 的变量。 如果是， 引擎就会使用这个变量； 如果否， 引擎会继续查找该变量（查看 1.3
节）。

如果引擎最终找到了 a 变量， 就会将 2 赋值给它。 否则引擎就会举手示意并抛出一个异常！

---
> * 作用域提升的主要原因是因为在编译的时候对代码进行 拆解 和 优化。以至于出现 你的认知 和 编译器的认知 不是同一个。


### 作用域的思考

LHS 和 RHS 的含义是“赋值操作的左侧或右侧” 并不一定意味着就是“=赋值操作符的左侧或右侧”。 赋值操作还有其他几种形式， 因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）” 以及“谁是赋值操作的源头（RHS）”。

> * LHS 和 RHS 可以理解为 作用域 的 左边界 和 右边界。{LHS ... 作用域 ... RHS}

### 严格模式
ES5 中引入了“严格模式”。 同正常模式， 或者说宽松 / 懒惰模式相比， 严格模式在行为上有很多不同。 其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。 因此， 在严格模式中 LHS 查询失败时， 并不会创建并返回一个全局变量， 引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。

## 欺骗词法
* eval
* with
> - eval(..) 函数如果接受了含有一个或多个声明的代码， 就会修改其所处的词法作用域， 而with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。
> - 另外一个不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响（限制）。 with 被完全禁止， 而在保留核心功能的前提下， 间接或非安全地使用eval(..) 也被禁止了。


## 函数作用域
### 匿名和具名
匿名函数表达式书写起来简单快捷
缺点：
+ 1. 匿名函数在栈追踪中不会显示出有意义的函数名， 使得调试很困难。
+ 2. 如果没有函数名， 当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。 另一个函数需要引用自身的例子， 是在事件触发后事件监听器需要解绑自身。
+ 3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。 一个描述性的名称可以让代码不言自明。

```javascript
setTimeout( function timeoutHandler() { // <-- 快看， 我有名字了！
console.log( "I waited 1 second!" );
}, 1000 );
```

### 立即执行函数表达式
由于函数被包含在一对 ( ) 括号内部， 因此成为了一个表达式， 通过在末尾加上另外一个( ) 可以立即执行这个函数， 比如 (function foo(){ .. })()。 第一个 ( ) 将函数变成表达式， 第二个 ( ) 执行了这个函数。

## 块作用域
+ 变量的声明应该距离使用的地方越近越好， 并最大限度地本地化。
+ 块作用域是一个用来对之前的最小授权原则进行扩展的工具， 将代码从在函数中隐藏信息扩展为在块中隐藏信息。
+ with 用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。
+ try/catch ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域， 其中声明的变量仅在 catch 内部有效。

```javascript
try {
undefined(); // 执行一个非法操作来强制制造一个异常
}
catch (err) {
console.log( err ); // 能够正常执行！
} c
onsole.log( err ); // ReferenceError: err not found
```
+ let let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。 换句话说， let为其声明的变量隐式地了所在的块作用域。

### 作用域提升
是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会在块作用域中进行提升。 声明的代码被运行之前， 声明并不“存在”。

```javascript
{
  console.log( bar ); // ReferenceError!
  let bar = 2;
}
```
### 垃圾收集
1
