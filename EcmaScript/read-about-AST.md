# 理解作用域
我们学习作用域的方式是将这个过程模拟成几个人物之间的对话。 那么， 由谁进行这场对话呢？

* #### 引擎
从头到尾负责整个 JavaScript 程序的编译及执行过程。

* #### 编译器
引擎的好朋友之一， 负责语法分析及代码生成等脏活累活（详见前一节的内容）。

* #### 作用域
引擎的另一位好朋友， 负责收集并维护由所有声明的标识符（变量） 组成的一系列查询， 并实施一套非常严格的规则， 确定当前执行的代码对这些标识符的访问权限。

## var a = 2 编译步骤
下面我们将 var a = 2; 分解， 看看引擎和它的朋友们是如何协同工作的。编译器首先会将这段程序分解成词法单元， 然后将词法单元解析成一个树结构。 但是当编译器开始进行代码生成时， 它对这段程序的处理方式会和预期的有所不同。
可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量分配内存， 将其命名为 a， 然后将值 2 保存进这个变量。” 然而， 这并不完全正确。事实上编译器会进行如下处理。

1. 遇到 var a， 编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。 如果是， 编译器会忽略该声明， 继续进行编译； 否则它会要求作用域在当前作用域的集合中声明一个新的变量， 并命名为 a。

2. 接下来编译器会为引擎生成运行时所需的代码， 这些代码被用来处理 a = 2 这个赋值操作。 引擎运行时会首先询问作用域， 在当前的作用域集合中是否存在一个叫作 a 的变量。 如果是， 引擎就会使用这个变量； 如果否， 引擎会继续查找该变量（查看 1.3
节）。

如果引擎最终找到了 a 变量， 就会将 2 赋值给它。 否则引擎就会举手示意并抛出一个异常！

---
> * 作用域提升的主要原因是因为在编译的时候对代码进行 拆解 和 优化。以至于出现 你的认知 和 编译器的认知 不是同一个。


### 作用域的思考

LHS 和 RHS 的含义是“赋值操作的左侧或右侧” 并不一定意味着就是“=赋值操作符的左侧或右侧”。 赋值操作还有其他几种形式， 因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）” 以及“谁是赋值操作的源头（RHS）”。

> * LHS 和 RHS 可以理解为 作用域 的 左边界 和 右边界。{LHS ... 作用域 ... RHS}

### 严格模式
ES5 中引入了“严格模式”。 同正常模式， 或者说宽松 / 懒惰模式相比， 严格模式在行为上有很多不同。 其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。 因此， 在严格模式中 LHS 查询失败时， 并不会创建并返回一个全局变量， 引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。

## 欺骗词法
* eval
* with
> - eval(..) 函数如果接受了含有一个或多个声明的代码， 就会修改其所处的词法作用域， 而with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。
> - 另外一个不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响（限制）。 with 被完全禁止， 而在保留核心功能的前提下， 间接或非安全地使用eval(..) 也被禁止了。


## 函数作用域
### 匿名和具名
匿名函数表达式书写起来简单快捷
缺点：
+ 1. 匿名函数在栈追踪中不会显示出有意义的函数名， 使得调试很困难。
+ 2. 如果没有函数名， 当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。 另一个函数需要引用自身的例子， 是在事件触发后事件监听器需要解绑自身。
+ 3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。 一个描述性的名称可以让代码不言自明。

```javascript
setTimeout( function timeoutHandler() { // <-- 快看， 我有名字了！
console.log( "I waited 1 second!" );
}, 1000 );
```

### 立即执行函数表达式
由于函数被包含在一对 ( ) 括号内部， 因此成为了一个表达式， 通过在末尾加上另外一个( ) 可以立即执行这个函数， 比如 (function foo(){ .. })()。 第一个 ( ) 将函数变成表达式， 第二个 ( ) 执行了这个函数。

## 块作用域
+ 变量的声明应该距离使用的地方越近越好， 并最大限度地本地化。
+ 块作用域是一个用来对之前的最小授权原则进行扩展的工具， 将代码从在函数中隐藏信息扩展为在块中隐藏信息。
+ with 用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。
+ try/catch ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域， 其中声明的变量仅在 catch 内部有效。

```javascript
try {
undefined(); // 执行一个非法操作来强制制造一个异常
}
catch (err) {
console.log( err ); // 能够正常执行！
} c
onsole.log( err ); // ReferenceError: err not found
```
+ let let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。 换句话说， let为其声明的变量隐式地了所在的块作用域。

### 作用域提升
* 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。
* 是函数会首先被提升， 然后才是变量。
* 在同一个作用域中进行重复定义是非常糟糕的， 而且经常会导致各种奇怪的问题

是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会在块作用域中进行提升。 声明的代码被运行之前， 声明并不“存在”。

```javascript
{
  console.log( bar ); // ReferenceError!
  let bar = 2;
}
```

```javascript
a = 2;
var a;
console.log( a );
```
我们的第一个代码片段会以如下形式进行处理：
```javascript
var a;
a = 2;
console.log( a );
```
其中第一部分是编译， 而第二部分是执行。

考虑以下代码：
```javascript
foo(); // 1
var foo;
function foo() {
  console.log( 1 );
} 
foo = function() {
  console.log( 2 );
};
```
会输出 1 而不是 2 ！ 这个代码片段会被引擎理解为如下形式：
```javascript
function foo() {
  console.log( 1 );
} 
foo(); // 1
foo = function() {
  console.log( 2 );
};
```

### 垃圾收集
#### 一、垃圾回收的必要性
由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成**系统崩溃**。
#### 二、垃圾回收原理浅析
现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。
##### 1、标记清除
垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。
##### 2、引用计数
引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。
但是用这种方法存在着一个问题，下面来看看代码：
```javascript
function problem() {
    var objA = new Object();
    var objB = new Object();

    objA.someOtherObject = objB;
    objB.anotherObject = objA;
}
```
在这个例子中，objA和objB通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。
**这样的相互引用如果说很大量的存在就会导致大量的内存泄露。**

不过上面的问题也不是不能解决，我们可以手动切断他们的循环引用。
```javascript
myObj.element = null;
element.someObject =null;
```

#### 减少JavaScript中的垃圾回收
首先，最明显的，**new关键字就意味着一次内存分配**，例如 new Foo()。最好的处理方法是：在初始化的时候新建对象，然后在后续过程中尽量多的**重用这些创建好的对象**。

另外还有以下三种内存分配表达式（可能不像new关键字那么明显了）：

* {} （创建一个新对象）
* [] （创建一个新数组）
* function() {…} (创建一个新的方法，注意：新建方法也会导致垃圾收集！！)

##### 1、对象object优化
那就是遍历此对象的所有属性，并逐个删除，最终将对象清理为一个空对象。
cr.wipe(obj)方法就是为此功能而生，代码如下： 
```javascript
// 删除obj对象的所有属性，高效的将obj转化为一个崭新的对象！
cr.wipe = function (obj) {
    for (var p in obj) {
         if (obj.hasOwnProperty(p))
            delete obj[p];
    }
};
```
##### 2、数组array优化
实际上，将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。

##### 3、方法function优化
方法 一般都是在初始化的时候创建，并且此后很少在运行时进行动态内存分配，这就使得导致内存垃圾产生的方法，找起来就不是那么容易了。但是从另一角度来说，这更便于我们寻找了，因为只要是动态创建方法的地方，就有可能产生内存垃圾。例如：将方法作为返回值，就是一个动态创建方法的实例。

在游戏的主循环中，setTimeout或requestAnimationFrame来调用一个成员方法是很常见的，例如：
```javascript
setTimeout(
    (function(self) {                    
      return function () {
              self.tick();
    };
})(this), 16)
```
每过16毫秒调用一次this.tick()，嗯，乍一看似乎没什么问题，但是仔细一琢磨，每一次调用都返回了一个新的方法对象，这就导致了大量的方法对象垃圾！

为了解决这个问题，可以将作为返回值的方法保存起来，例如：
```javascript
// at startup
this.tickFunc = (
    function(self) {
      return function() {
                self.tick();
      };
    }
)(this);

// in the tick() function
setTimeout(this.tickFunc, 16);
```
相比于每次都新建一个方法对象，这种方式在每一帧当中重用了相同的方法对象。这种方式的优势是显而易见的，而这种思想也可以应用在任何以方法为返回值或者在运行时创建方法的情况当中。

##### 4、高级技术

　　从根本上来说，javascript本身就是围绕着垃圾收集来设计的。随着我们工作的进行，避免内存垃圾变得越来越困难。因为很多方便实用的Javascript库方法也会产生一些新的对象。对于这些库方法产生的垃圾，我们束手无策，只能重新翻看文档，并且检查方法的返回值。例如，**数组的slice方法返回一个新的数组**（在不修改原数组的基础上，截取出一部分作为新数组），**字符串的substr方法返回一个新的字符串**（在不修改原字符串的基础上，截取出一部分字符串作为返回值）等等。

　　调用这些库方法，将会创建内存垃圾，而你能做的，只有避免调用这些方法，或者用不创建系统垃圾的方式重写这些方法（有点极端啦~）。

　　例如，在Construct 2引擎中，从数组中利用下标来删除一个元素，是经常进行的操作。最初我们是用下面这种方式来实现的：
```javascript
var sliced = arr.slice(index + 1);
arr.length = index;
arr.push.apply(arr, sliced);
```
　　然而，slice方法会返回一个新的数组对象（数组中的元素是原数组中删掉的部分），并且会通过arr.push.apply方法将元素重新复制回原数组，但是在此操作之后，该数组就成为了一片内存垃圾。由于这是我们引擎中的垃圾产生的热点代码（使用频率非常很高），因此我们利用了迭代的方式重写了上述代码：
```javascript
for (var i = index, len = arr.length – 1; i < len; i++)
    arr[i] = arr[i + 1];
arr.length = len;
```
　　显然，重写大量的库函数是非常痛苦的，因此你必须仔细权衡方法的易用性和内存垃圾产生情况。如果产生大量内存垃圾的方法在动画的每一帧中被多次调用，你可能就会兴高采烈的重写库函数啦。

　　在递归函数中，通过{}构造空对象，并在递归过程中传递数据，虽然是很方便的。但是更好的方式是：利用一个单独的数组对象作为堆栈，在递归过程中对数组进行push和pop操作。更进一步，不要调用array的pop方法（pop将会使得array的最后一个元素将会变成内存垃圾），而应该使用一个索引来记录数组的最后一个元素的位置，在pop时简单的将索引减一即可；类似的，将索引加1来代替array的push操作，只有当索引对应的元素不存在时，才执行真正的push为数组加入一个新元素。

　　另外，在任何时候，都应该避免使用向量对象（例如：包含x和y属性的vector2对象）。有些方法将向量对象作为方法返回值，既可以支持返回值的再次修改，又能够将需要的属性一次性返回，使用起来非常方便。但是有时候在一帧动画中，创建了成百上千个这样的向量对象，从而导致严重的垃圾回收性能问题，也是非常常见的。因此最好将这些方法分离成具有独立职责的功能个体，例如：利用getX()和getY()方法（返回具体数据）代替getPosition()方法（返回一个vector2对象）。
  
> 针对有指数级操作的时候，使用不会产生内存垃圾的方法会更加的优秀

### 作用域闭包

## 现代的模块机制
* ES5
```javascript
var MyModules = (function Manager() {
  var modules = {};
  
  function define(name, deps, impl) {
    for (var i=0; i<deps.length; i++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply( impl, deps );
  }
  
  function get(name) {
    return modules[name];
  }
  
  return {
    define: define,
    get: get
  };
})();

//下面展示了如何使用它来定义模块：
MyModules.define( "bar", [], function() {
  function hello(who) {
    return "Let me introduce: " + who;
  }
  return {
    hello: hello
  };
});

MyModules.define( "foo", ["bar"], function(bar) {
  var hungry = "hippo";
  function awesome() {
    console.log( bar.hello( hungry ).toUpperCase() );
  }
  return {
    awesome: awesome
  };
});

var bar = MyModules.get( "bar" );
var foo = MyModules.get( "foo" );

console.log(
  bar.hello( "hippo" )
); // Let me introduce: hippo

foo.awesome(); // LET ME INTRODUCE: HIPPO
```

这段代码的核心是 **modules[name] = impl.apply(impl, deps)。** 为了模块的定义引入了包装函数（可以传入任何依赖）， 并且将返回值， 也就是模块的 API， 储存在一个根据名字来管理的模块列表中。

* ES6
bar.js
```javascript
function hello(who) {
return "Let me introduce: " + who;
}
export hello;
```
foo.js
```javascript
// 仅从 "bar" 模块导入 hello()
import hello from "bar";
var hungry = "hippo";
function awesome() {
console.log(
hello( hungry ).toUpperCase()
);
}
export awesome;
```

模块有两个主要特征：
* （1） 为创建内部作用域而调用了一个包装函数；
* （2） 包装函数的返回值必须至少包括一个对内部函数的引用， 这样就会创建涵盖整个包装函数内部作用域的闭包。

