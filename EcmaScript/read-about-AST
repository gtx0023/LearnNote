# var a = 2 编译步骤
下面我们将 var a = 2; 分解， 看看引擎和它的朋友们是如何协同工作的。编译器首先会将这段程序分解成词法单元， 然后将词法单元解析成一个树结构。 但是当编译器开始进行代码生成时， 它对这段程序的处理方式会和预期的有所不同。
可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括：“为一个变量分配内存， 将其命名为 a， 然后将值 2 保存进这个变量。” 然而， 这并不完全正确。事实上编译器会进行如下处理。

1. 遇到 var a， 编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。 如果是， 编译器会忽略该声明， 继续进行编译； 否则它会要求作用域在当前作用域的集合中声明一个新的变量， 并命名为 a。

2. 接下来编译器会为引擎生成运行时所需的代码， 这些代码被用来处理 a = 2 这个赋值操作。 引擎运行时会首先询问作用域， 在当前的作用域集合中是否存在一个叫作 a 的变量。 如果是， 引擎就会使用这个变量； 如果否， 引擎会继续查找该变量（查看 1.3
节）。

如果引擎最终找到了 a 变量， 就会将 2 赋值给它。 否则引擎就会举手示意并抛出一个异常！
