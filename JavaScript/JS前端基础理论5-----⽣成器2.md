## ⽣成器 +Promise  

ES6 中最完美的世界就是⽣成器（看似同步的异步代码）和 Promise（可信任可组合）的结合。 但如何实现呢？  

让我们来试⼀下！⾸先，把⽀持 Promise 的 foo(..) 和⽣成器*main() 放在⼀起：

```javascript
function foo(x,y) {
    return request(
    	"http://some.url.1/?x=" + x + "&y=" + y
    );
}
function *main() {
    try {
        var text = yield foo( 11, 31 );
        console.log( text );
    }
    catch (err) {
    	console.error( err );
    }
}  
```

来实现接收和连接 yield 出来的 promise，使它能够在决议之后恢复⽣成器。先从⼿⼯实现开始：

```javascript
var it = main();
var p = it.next().value;
// 等待promise p决议
p.then(
    function(text){
    	it.next( text );
    },
    function(err){
    	it.throw( err );
    }
);  
```

这段代码看起来应该和我们前⾯⼿⼯组合通过 error-first 回调控制的⽣成器⾮常类似。除了没有 if (err) { it.throw.. ，promise已经为我们分离了完成（成功）和拒绝（失败），否则的话，迭代器控制是完全⼀样的。  

优点：

- 我们利⽤了已知 *main() 中只有⼀个需要⽀持Promise 的步骤这⼀事实。

缺点：

- 不希望每个⽣成器⼿⼯编写不同的 Promise 链！如果有⼀种⽅法可以实现重复（即循环）迭代控制，每次会⽣成⼀个 Promise，等其决议后再继续
- 还有，如果在 it.next(..) 调⽤过程中⽣成器（有意或⽆意）抛出⼀个错误会怎样呢？是应该退出呢，还是应该捕获这个错误并发送回去呢？类似地，如果通过 it.throw(..) 把⼀个 Promise 拒绝抛⼊⽣成器中，但它却没有受到处理就被直接抛回了呢？  

### ⽀持 Promise 的 Generator Runner  

```javascript
// 在此感谢Benjamin Gruenbaum （@benjamingr on GitHub）的巨⼤改进！
function run(gen) {
    var args = [].slice.call( arguments, 1), it;// 在当前上下⽂中初始化⽣成器
    it = gen.apply( this, args );
    // 返回⼀个promise⽤于⽣成器完成
    return Promise.resolve()
    .then( function handleNext(value){
        // 对下⼀个yield出的值运⾏
        var next = it.next( value );
        return (function handleResult(next){
            // ⽣成器运⾏完毕了吗？
            if (next.done) {
            	return next.value;
            }
            // 否则继续运⾏
            else {
                return Promise.resolve( next.value )
                .then(
                    // 成功就恢复异步循环，把决议的值发回⽣成器
                    handleNext,
                    // 如果value是被拒绝的 promise，
                    // 就把错误传回⽣成器进⾏出错处理
                    function handleErr(err) {
                        return Promise.resolve(
                        	it.throw( err )
                        )
                        .then( handleResult );
                    }
                );
            }
        })(next);
    } );
}
```

如何在运⾏ Ajax 的例⼦中使⽤ run(..) 和 *main() 呢？

```javascript
function *main() {
	// ..
}
run( main );
```

就是这样！这种运⾏ run(..) 的⽅式，它会⾃动异步运⾏你传给它的⽣成器，直到结束。  

#### ES7：async 与 await ?  

```javascript
function foo(x,y) {
    return request(
    	"http://some.url.1/?x=" + x + "&y=" + y
    );
}
async function main() {
    try {
        var text = await foo( 11, 31 );
        console.log( text );
    }
    catch (err) {
    	console.error( err );
    }
}
main();
```

- 可以看到，这⾥没有通过 run(..) 调⽤（意味着不需要库⼯具！）来触发和驱动 main() ，它只是被当作⼀个普通函数调⽤。
- main() 也不再被声明为⽣成器函数了，它现在是⼀类新的函数：async 函数。
- 我们不再 yield 出 Promise，⽽是⽤ await等待它决议。  

### ⽣成器中的 Promise 并发  

场景：你需要从两个不同的来源获取数据，然后把响应
组合在⼀起以形成第三个请求，最终把最后⼀条响应打印出来。  

最简单的⽅法：

```javascript
function *foo() {
    // 让两个请求"并⾏"
    var p1 = request( "http://some.url.1" );
    var p2 = request( "http://some.url.2" );
    // 等待两个promise都决议
    var r1 = yield p1;
    var r2 = yield p2;
    var r3 = yield request(
    	"http://some.url.3/?v=" + r1 + "," + r2
    );
    console.log( r3 );
}
// 使⽤前⾯定义的⼯具run(..)
run( foo );  
```

p1 和 p2 都会并发执⾏，⽆论完成顺序如何，两者都
要全部完成，然后才会发出 r3 = yield request.. Ajax 请求。  

通过 Promise.all([ .. ]) ⼯具实现的 gate 模式相
同。  

```javascript
function *foo() {
    // 让两个请求"并⾏"，并等待两个promise都决议
    var results = yield Promise.all( [
        request( "http://some.url.1" ),
        request( "http://some.url.2" )
    ] );
    var r1 = results[0];
    var r2 = results[1];
    var r3 = yield request(
        "http://some.url.3/?v=" + r1 + "," + r2
    );
    console.log( r3 );
}
// 使⽤前⾯定义的⼯具run(..)
run( foo );  
```

#### 隐藏的 Promise  

可能是⼀个更简洁的⽅案：

```javascript
// 注：普通函数，不是⽣成器
function bar(url1,url2) {
    return Promise.all( [
        request( url1 ),
        request( url2 )
    ] );
}
function *foo() {
    // 隐藏bar(..)内部基于Promise的并发细节
    var results = yield bar(
        "http://some.url.1",
        "http://some.url.2"
    );
    var r1 = results[0];
    var r2 = results[1];
    var r3 = yield request(
    	"http://some.url.3/?v=" + r1 + "," + r2
    );
    console.log( r3 );
}
// 使⽤前⾯定义的⼯具run(..)
run( foo );  
```

⾮常有⽤的做法是：把你的 Promise 逻辑隐藏在⼀个只从⽣成器代码中调⽤的函数内部。⽐如：

```javascript
function bar() {
    Promise.all( [
    	baz( .. )
    	.then( .. ),
    	Promise.race( [ .. ] )
    ] )
    .then( .. )
}  
```

## ⽣成器委托  

### yield 委托  

yield 委托的具体语法是：yield * （注意多出来的
\* ）。在我们弄清它在前⾯的例⼦中的使⽤之前，先来看⼀个简单点
的场景：

```javascript
function *foo() {
    console.log( "*foo() starting" );
    yield 3;
    yield 4;
    console.log( "*foo() finished" );
}
function *bar() {
    yield 1;
    yield 2;
    yield *foo(); // yield委托！
    yield 5;
}
var it = bar();
it.next().value; // 1
it.next().value; // 2
it.next().value; // *foo()启动
// 3
it.next().value; // 4
it.next().value; // *foo()完成
// 5  
```

yield *foo() 委托是如何⼯作的呢？

⾸先，和我们以前看到的完全⼀样，调⽤ foo() 创建⼀个迭代器。然后 yield * 把迭代器实例控制（当前 *bar() ⽣成器的）委托给 /转移到了这另⼀个 *foo() 迭代器。

所以，前⾯两个 it.next() 调⽤控制的是 *bar() 。但当我们发出第三个 it.next() 调⽤时，*foo() 现在启动了，我们现在控制的是*foo() ⽽不是 *bar() 。这也是为什么这被称为委托：*bar() 把⾃⼰的迭代控制委托给了 *foo() 。

⼀旦 it 迭代器控制消耗了整个 *foo() 迭代器，it 就会⾃动转回控制 *bar() 。  

### 为什么⽤委托  

主要⽬的是代码组织，以达到与普通函数调⽤的对称。  

### 消息委托  

认真跟踪下⾯的通过 yield 委托实现的消息流出⼊：

```javascript
function *foo() {
    console.log( "inside *foo():", yield "B" );
    console.log( "inside *foo():", yield "C" );
    return "D";
}
function *bar() {
    console.log( "inside *bar():", yield "A" );
    // yield委托！
    console.log( "inside *bar():", yield *foo() );
    console.log( "inside *bar():", yield "E" );
    return "F";
}
var it = bar();
console.log( "outside:", it.next().value );
// outside: A
console.log( "outside:", it.next( 1 ).value );
// inside *bar(): 1
// outside: B
console.log( "outside:", it.next( 2 ).value );
// inside *foo(): 2
// outside: C
console.log( "outside:", it.next( 3 ).value );
// inside *foo(): 3
// inside *bar(): D
// outside: E
console.log( "outside:", it.next( 4 ).value );
// inside *bar(): 4
// outside: F
```

要特别注意 it.next(3) 调⽤之后的执⾏步骤。

1. 值 3 （通过 *bar() 内部的 yield 委托）传⼊等待的 *foo()内部的 yield "C" 表达式。
2. 然后 *foo() 调⽤ return "D" ，但是这个值并没有⼀直返回到外部的 it.next(3) 调⽤。
3. 取⽽代之的是，值 "D" 作为 *bar() 内部等待的 yield*foo()表达式的结果发出——这个 yield 委托本质上在所有的 *foo() 完成之前是暂停的。所以 "D" 成为 *bar() 内部的最后结果，并被打印出来。
4. yield "E" 在 *bar() 内部调⽤，值 "E" 作为 it.next(3) 调⽤的结果被 yield 发出。

从外层的迭代器（it ）⾓度来说，是控制最开始的⽣成器还是控制委托的那个，没有任何区别。  

yield 委托甚⾄并不要求必须转到另⼀个⽣成器，它可以转到⼀个⾮⽣成器的⼀般 iterable。⽐如：

```javascript
function *bar() {
console.log( "inside *bar():", yield "A" );
// yield委托给⾮⽣成器！
console.log( "inside *bar():", yield *[ "B", "C", "D" ] );
console.log( "inside *bar():", yield "E" );
return "F";
}
var it = bar();
console.log( "outside:", it.next().value );
// outside: A
console.log( "outside:", it.next( 1 ).value );
// inside *bar(): 1
// outside: B
console.log( "outside:", it.next( 2 ).value );
// outside: C
console.log( "outside:", it.next( 3 ).value );
// outside: D
console.log( "outside:", it.next( 4 ).value );
// inside *bar(): undefined
// outside: E
console.log( "outside:", it.next( 5 ).value );
// inside *bar(): 5
// outside: F
```

注意这个例⼦和之前那个例⼦在消息接收位置和报告位置上的区别。

最显著的是，默认的数组迭代器并不关⼼通过 next(..) 调⽤发送的任何消息，所以值 2 、3 和 4 根本就被忽略了。还有，因为迭代器没有显式的返回值（和前⾯使⽤的 *foo() 不同），所以 yield * 表达式完成后得到的是⼀个 undefined 。  

#### 异常也被委托！  

和 yield 委托透明地双向传递消息的⽅式⼀样，错误和异常也是双向传递的：

```javascript
function *foo() {
    try {
    	yield "B";
    }
    catch (err) {
    	console.log( "error caught inside *foo():", err );
    }
    yield "C";
    throw "D";
}
function *bar() {
    yield "A";
    try {
    	yield *foo();
    }
    catch (err) {
    	console.log( "error caught inside *bar():", err );
    }
    yield "E";
    yield *baz();
    // 注：不会到达这⾥！
    yield "G";
}
function *baz() {
	throw "F";
}
var it = bar();
console.log( "outside:", it.next().value );
// outside: A
console.log( "outside:", it.next( 1 ).value );
// outside: B
console.log( "outside:", it.throw( 2 ).value );
// error caught inside *foo(): 2
// outside: C
console.log( "outside:", it.next( 3 ).value );
// error caught inside *bar(): D
// outside: E
try {
	console.log( "outside:", it.next( 4 ).value );
}
catch (err) {
	console.log( "error caught outside:", err );
}
// error caught outside: F
```

这段代码中需要注意以下⼏点。

1. 调⽤ it.throw(2) 时，它会发送错误消息 2 到 *bar() ，它⼜将其委托给 *foo() ，后者捕获并处理它。然后，yield "C" 把"C" 发送回去作为 it.throw(2) 调⽤返回的 value 。
2. 接下来从 *foo() 内 throw 出来的值 "D" 传播到 *bar() ，这个函数捕获并处理它。然后 yield "E" 把 "E" 发送回去作为it.next(3) 调⽤返回的 value 。
3. 然后，从 *baz() throw 出来的异常并没有在 *bar() 内被捕获——所以 *baz() 和 *bar() 都被设置为完成状态。这段代码之后，就再也⽆法通过任何后续的 next(..) 调⽤得到值 "G" ，next(..)调⽤只会给 value 返回 undefined 。  

### 异步委托  

```javascript
function *foo() {
    var r2 = yield request( "http://some.url.2" );
    var r3 = yield request( "http://some.url.3/?v=" + r2 );
    return r3;
}
function *bar() {
    var r1 = yield request( "http://some.url.1" );
    var r3 = yield *foo();
    console.log( r3 );
}
run( bar );
```

### 递归委托  

使⽤ yield 委托实现异步的⽣成器递归 ，即⼀个yield 委托到它⾃⾝的⽣成器：

```javascript
function *foo(val) {
    if (val > 1) {
        // ⽣成器递归
        val = yield *foo( val - 1 );
    }
    return yield request( "http://some.url/?v=" + val );
}
function *bar() {
    var r1 = yield *foo( 3 );
    console.log( r1 );
}
run( bar );  
```

接下来的细节描述可能会⾮常复杂。  

1. run(bar) 启动⽣成器 *bar() 。
2. foo(3) 创建了⼀个 *foo(..) 的迭代器，并传⼊ 3 作为其参数val 。
3. 因为 3 > 1 ，所以 foo(2) 创建了另⼀个迭代器，并传⼊ 2 作为其参数 val 。
4. 因为 2 > 1 ，所以 foo(1) ⼜创建了⼀个新的迭代器，并传⼊ 1作为其参数 val 。
5. 因为 1 > 1 不成⽴，所以接下来以值 1 调⽤ request(..) ，并从这第⼀个 Ajax 调⽤得到⼀个 promise。
6. 这个 promise 通过 yield 传出，回到 *foo(2) ⽣成器实例。  
7. yield * 把这个 promise 传出回到 *foo(3) ⽣成器实例。另⼀个 yield * 把这个 promise 传出回到 *bar() ⽣成器实例。再有⼀个 yield * 把这个 promise 传出回到 run(..) ⼯具，这个⼯具会等待这个 promsie（第⼀个 Ajax 请求）的处理。
8. 这个 promise 决议后，它的完成消息会发送出来恢复 *bar() ；后者通过 yield * 转⼊ *foo(3) 实例；后者接着通过 yield * 转⼊ *foo(2) ⽣成器实例；后者再接着通过 yield * 转⼊ *foo(3)⽣成器实例内部的等待着的普通 yield 。
9. 第⼀个调⽤的 Ajax 响应现在⽴即从 *foo(3) ⽣成器实例中返回。这个实例把值作为 *foo(2) 实例中 yield * 表达式的结果返回，赋给它的局部变量 val 。
10. 在 *foo(2) 中，通过 request(..) 发送了第⼆个 Ajax 请求。它的 promise 通过 yield 发回给 *foo(1) 实例，然后通过yield * ⼀路传递到 run(..) （再次进⾏步骤 7）。这个 promise决议后，第⼆个 Ajax 响应⼀路传播回到 *foo(2) ⽣成器实例，赋给它的局部变量 val。
11. 最后，通过 request(..) 发出第三个 Ajax 请求，它的promise 传出到 run(..) ，然后它的决议值⼀路返回，然后return 返回到 *bar() 中等待的 yield * 表达式。  

## ⽣成器并发  

```javascript
// request(..)是⼀个⽀持Promise的Ajax⼯具
var res = [];
function *reqData(url) {
    var data = yield request( url );
    // 控制转移
    yield;
    res.push( data );
}
var it1 = reqData( "http://some.url.1" );
var it2 = reqData( "http://some.url.2" );
var p1 = it.next();
var p2 = it.next();
p1.then( function(data){
	it1.next( data );
} );
p2.then( function(data){
	it2.next( data );
} );
Promise.all( [p1,p2] )
.then( function(){
    it1.next();
    it2.next();
} );
```

好吧，这看起来好⼀点（尽管仍然是⼿⼯的！），因为现在*reqData(..) 的两个实例确实是并发运⾏了，⽽且（⾄少对于前⼀部分来说）是相互独⽴的。  

来设想⼀下使⽤⼀个称为runAll(..) 的⼯具：

```javascript
// request(..)是⼀个⽀持Promise的Ajax⼯具
var res = [];
runAll(
    function*(){
        var p1 = request( "http://some.url.1" );
        // 控制转移
        yield;
        res.push( yield p1 );
    },
    function*(){
        var p2 = request( "http://some.url.2" );
        // 控制转移
        yield;
        res.push( yield p2 );
    }
);  
```

以下是 runAll(..) 内部运⾏的过程。

1. 第⼀个⽣成器从第⼀个来⾃于 "http://some.url.1" 的 Ajax响应得到⼀个 promise，然后把控制 yield 回 runAll(..) ⼯具。
2. 第⼆个⽣成器运 ⾏，对于 "http://some.url.2" 实现同样的操 作，把控制 yield 回 runAll(..) ⼯具。
3. 第⼀个⽣成器恢复运⾏，通过 yield 传出其 promise p1 。在这种情况下，runAll(..) ⼯具所做的和我们之前的 run(..) ⼀样，因为它会等待这个 promise 决议，然后恢复同⼀个⽣成器（没有控制转移！）。p1 决议后，runAll(..) 使⽤这个决议值再次恢复第⼀个⽣成器，然后 res[0] 得到了⾃⼰的值。接着，在第⼀个⽣成器完成的时候，有⼀个隐式的控制转移。
4. 第⼆个⽣成器恢复运⾏，通过 yield 传出其 promise p2 ，并等待其决议。⼀旦决议，runAll(..) 就⽤这个值恢复第⼆个⽣成器，设置 res[1] 。  

```javascript
// request(..)是⼀个⽀持Promise的Ajax⼯具
runAll(
    function*(data){
        data.res = [];
        // 控制转移（以及消息传递）
        var url1 = yield "http://some.url.2";
        var p1 = request( url1 ); // "http://some.url.1"
        // 控制转移
        yield;
        data.res.push( yield p1 );
    },
    function*(data){
        // 控制转移（以及消息传递）
        var url2 = yield "http://some.url.1";
        var p2 = request( url2 ); // "http://some.url.2"
        // 控制转移
        yield;
        data.res.push( yield p2 );
    }
);
```

在这⼀⽅案中，实际上两个⽣成器不只是协调控制转移，还彼此通信，通过 data.res 和 yield 的消息来交换 url1 和 url2 的值。真是极其强⼤！  

通信顺序进程 （Communicating Sequential Processes，CSP）的更⾼级异步技术提供了⼀个概念基础。  

## 形实转换程序  

JavaScript 中的 thunk 是指⼀个⽤于调⽤另外⼀个函数的函数，没有任何参数。

换句话说，你⽤⼀个函数定义封装函数调⽤，包括需要的任何参数，来定义这个调⽤的执⾏，那么这个封装函数就是⼀个形实转换程序。之后在执⾏这个 thunk 时，最终就是调⽤了原始的函数。  

考虑：

```javascript
function thunkify(fn) {
    var args = [].slice.call( arguments, 1 );
    return function(cb) {
        args.push( cb );
        return fn.apply( null, args );
    };
}
var fooThunk = thunkify( foo, 3, 4 );
// 将来
fooThunk( function(sum) {
	console.log( sum ); // 7
} );  
```

前⾯ thunkify(..) 的实现接收 foo(..) 函数引⽤以及它需要的任意参数，并返回 thunk 本⾝（fooThunk(..) ）。但是，这并不是JavaScript 中使⽤ thunk 的典型⽅案。

典型的⽅法——如果不令⼈迷惑的话——并不是 thunkify(..) 构造thunk 本⾝，⽽是 thunkify(..) ⼯具产⽣⼀个⽣成 thunk 的函数。

考虑：

```javascript
function thunkify(fn) {
    return function() {
        var args = [].slice.call( arguments );
        return function(cb) {
            args.push( cb );
            return fn.apply( null, args );
        };
    };
} 
```

此处主要的区别在于多出来的 return function() { .. } 这⼀层。以下是⽤法上的区别：  

```javascript
var whatIsThis = thunkify( foo );
var fooThunk = whatIsThis( 3, 4 );
// 将来
fooThunk( function(sum) {
	console.log( sum ); // 7
} );  
```

## ES6 之前的⽣成器  

### ⼿⼯变换  

```javascript
function foo(url) {
    // 管理⽣成器状态
    var state;
    // ⽣成器变量范围声明
    var val;
    function process(v) {
        switch (state) {
            case 1:
                console.log( "requesting:", url );
                return request( url );
            case 2:
                val = v;
                console.log( val );
                return;
            case 3:
                var err = v;
                console.log( "Oops:", err );
                return false;
        }
    }
    // 构造并返回⼀个⽣成器
    return {
        next: function(v) {
            // 初始状态
            if (!state) {
                state = 1;
                return {
                    done: false,
                    value: process()
                };
            }
            // yield成功恢复
            else if (state == 1) {
                state = 2;
                return {
                    done: true,
                    value: process( v )
                };
            }
            // ⽣成器已经完成
            else {
                return {
                    done: true,
                    value: undefined
                };
            }
        },
        "throw": function(e) {
            // 唯⼀的显式错误处理在状态1
            if (state == 1) {
                state = 3;
                return {
                    done: true,
                    value: process( e )
                };
            }
            // 否则错误就不会处理，所以只把它抛回
            else {
                throw e;
            }
        }
    };
} 
```

这段代码是如何⼯作的呢？

1. (1) 对迭代器的 next() 的第⼀个调⽤会把⽣成器从未初始化状态转移到状态 1 ，然后调⽤ process() 来处理这个状态。
   request(..) 的返回值是对应 Ajax 响应的 promise，作为 value属性从 next() 调⽤返回。
2. (2) 如果 Ajax 请求成功，第⼆个 next(..) 调⽤应该发送 Ajax 响应值进来，这会把状态转移到状态 2 。再次调⽤ process(..) （这次包括传⼊的 Ajax 响应值），从 next(..) 返回的 value 属性将是undefined 。
3. (3) 然⽽，如果 Ajax 请求失败的话，就会使⽤错误调⽤ throw(..)，这会把状态从 1 转移到 3 （⽽⾮ 2 ）。再次调⽤ process(..)，这⼀次包含错误值。这个 case 返回 false ，被作为 throw(..)调⽤返回的 value 属性。

从外部来看（也就是说，只与迭代器交互），这个普通函数 foo(..)与⽣成器 *foo(..) 的⼯作⼏乎完全⼀样。所以我们已经成功地把ES6 ⽣成器转为了前 ES6 兼容代码  ！  

### ⾃动转换  

regenerator 就是这样的⼀个⼯具（http://facebook.github.io/regenerator/ ），出⾃ Facebook 的⼏个聪明⼈。  

如果使⽤ regenerator 来转换前⾯的⽣成器的话，以下是产⽣的代码
（本书写作之时）：

```javascript
// request(..)是⼀个⽀持Promise的Ajax⼯具
var foo = regeneratorRuntime.mark(function foo(url) {
    var val;
    return regeneratorRuntime.wrap(function foo$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                context$1$0.prev = 0;
                console.log( "requesting:", url );
                context$1$0.next = 4;
                return request( url );
            case 4:
                val = context$1$0.sent;
                console.log( val );
                context$1$0.next = 12;
                break;
            case 8:
                context$1$0.prev = 8;
                context$1$0.t0 = context$1$0.catch(0);
                console.log("Oops:", context$1$0.t0);
                return context$1$0.abrupt("return", false);
            case 12:
            case "end":
            return context$1$0.stop();
        }
    }, foo, this, [[0, 8]]);
});  
```

