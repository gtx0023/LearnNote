# JS前端基础理论-----集合

- 我们会从 TypedArray 开始探讨，严格说它是几年之前 ES5 时期的技术，但那时是作为 WebGL 而不是 JavaScript 组件。在 ES6 中，它已经被语言规范直接采纳，进入一级（first class）状态  
- Map 就像是一个对象（键 / 值对），但是键值并非只能为字符串，而是可以使用任何值——甚至是另一个对象或 map ！ Set 与数组（值的序列）类似，但是其中的值是唯一的；如果新增的值是重复的，就会被忽略。还有相应的弱（与内存 / 垃圾回收相关）版本：WeakMap 和 WeakSet。  

## TypedArray  

- 来处理视频、音频，或者通过WebSocks获取原始数据。
- 方便快捷地地用JavaScript处理原始二进制数据。JavaScript的类型化数组(TypedArrays)提供了一个更加高效的机制来访问和处理二进制数据。
- 将原始数据作为字符串来对待，并使用charCodeAt()来从数据缓冲区中读取字节。由于需要进行多次转换，这种方法低效而且容易出错，特别是当数据格式不是实际上的字节数据时（如32位整数或是浮点数）。



### TypedArrays构造：

- 缓冲区(Buffer)
- 视图(View)

为了达到最大的灵活性和高效性，JavaScript的TypedArray分为两个部分：缓冲区和视图。

#### 缓冲区

缓冲区由ArrayBuffer实现，一个缓冲区是一个代表某个数据块的对象。它没有格式，而且没有提供一个机制来访问或操纵其中的内容。

#### 视图

为了存取缓冲区中的内容，你需要创建一个视图。视图提供了一个环境(context)，包括数据类型、起始偏移量以及元素数量。它把数据转化为实际上的类型化数组。视图由 ArrayBufferView和它的一些子类实现。

 

ArrayBufferView的子类：

下面的子类提供了特定的缓冲区视图，用来处理不同类型的数据。要注意的是，如果要处理的数据类型超过一字节，将使用平台对应的端序。如果需要操作端序，可以使用DataView来代替ArrayBufferView。

[Int8Array](https://developer.mozilla.org/en/JavaScript_typed_arrays/Int8Array) 、[Uint8Array](https://developer.mozilla.org/en/JavaScript_typed_arrays/Uint8Array)、[Int16Array](https://developer.mozilla.org/en/JavaScript_typed_arrays/Int16Array)、[Uint16Array](https://developer.mozilla.org/en/JavaScript_typed_arrays/Uint16Array)、[Int32Array](https://developer.mozilla.org/en/JavaScript_typed_arrays/Int32Array)、[Uint32Array](https://developer.mozilla.org/en/JavaScript_typed_arrays/Uint32Array)、[Float32Array](https://developer.mozilla.org/en/JavaScript_typed_arrays/Float32Array)、[Float64Array](https://developer.mozilla.org/en/JavaScript_typed_arrays/Float64Array) 

 

ArrayBufferView的父类：

[DataView](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/DataView)：DataView提供了一个底层接口来从ArrayBuffer中存取数据

[StringView](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/StringView)：StringView提供了一个构建于ArrayBuffer之上的C语言风格的字符串操作接口（比如说字符编码的数组，类似JavaScript中的ArrayBufferView）

```javascript
//创建一个16字节的缓冲区，自动初始化为全0
var buffer = new ArrayBuffer(16);

//检测缓冲区大小
if (buffer.byteLength == 16 ) {
    alert("it's 16 bytes.");
}

//为了能操作这个缓冲区，我们创建一个视图，将缓冲区中的数据看成32位(4字节)有符号整数数组
var int32View = new Int32Array(buffer);

//现在可以像操作一个数组那样操作里面的数据了。下面的这个操作会把数组中的四个元素赋值为0,2,4,6
for (var i=0; i<int32View.length; i++) {
    int32View[i] = i*2;
}

//使用多个视图来操作同一个缓冲区。如果你的机器是小端序(一般都是小端序)，将显示[ 0, 0, 2, 0, 4, 0, 6, 0 ]。如果是大端序，显示[0, 0, 0, 2, 0, 4, 0, 6]
var int16View = new Int16Array(buffer);
console.log(int16View)
```

操作更复杂的数据结构

通过把不同类型、不同起始偏移量的数据组合成单个的缓冲区，我们可以创建和访问类似C语言结构体的数据。

如下面的结构体

```javascript
struct someStruct {
    unsigned long id;
    char username[16];
    float amountDue;
};
```

你可以这样访问

```javascript
var buffer = new ArrayBuffer(24);

// ... read the data into the buffer ...
//Uint16Array Uint16Array(ArrayBuffer buffer, optional unsigned long byteOffset, optional unsigned long length);//第一个参数是ArrayBuffer，第二个参数是偏移量(以字节计)，第三个参数是数据的长度(以字节计)
var idView = new Uint32Array(buffer, 0, 1);
var usernameView = new Uint8Array(buffer, 4, 16);
var amountDueView = new Float32Array(buffer, 20, 1);
```

转换成普通的数组

在处理完一个类型化的数组之后，有时我们想把它转化为一个普通的数组，因为这样可以使用数组原型提供的方便的方法。

```javascript
var typedArray = new Uint8Array( [ 1, 2, 3, 4 ] ),
     normalArray = Array.apply( [], typedArray );
normalArray.length === 4;
normalArray.constructor === Array;
```

兼容性

- Typed arrays 已经在 Webkit 中可用了. 
- Chrome 7 支持 `ArrayBuffer`, `Float32Array`, `Int16Array`, 和 `Uint8Array`.
- Chrome 9 和 Firefox 15 添加了 `DataView` 对象的支持. 
- Internet Explorer 10 除了 `Uint8ClampedArray` 和 `ArrayBuffer.prototype.slice 以外都支持`.

## 集合（Set）

ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。

**Set 本身是一种构造函数，用来生成 Set 数据结构。**

```javascript
new Set([iterable])
```

举个例子：

```javascript
const s = new Set()
[1, 2, 3, 4, 3, 2, 1].forEach(x => s.add(x))

for (let i of s) {
    console.log(i)	// 1 2 3 4
}

// 去重数组的重复对象
let arr = [1, 2, 3, 2, 1, 1]
[... new Set(arr)]	// [1, 2, 3]
```

Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。

向 Set 加入值的时候，不会发生类型转换，所以`5`和`"5"`是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于**精确相等**运算符（`===`），主要的区别是**`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。**

```javascript
let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}

let set1 = new Set()
set1.add(5)
set1.add('5')
console.log([...set1])	// [5, "5"]
```

### Set 实例属性

- constructor： 构造函数

- size：元素数量

  ```javascript
  let set = new Set([1, 2, 3, 2, 1])
  
  console.log(set.length)	// undefined
  console.log(set.size)	// 3
  ```

### Set 实例方法

#### 操作方法

- add(value)：新增，相当于 array里的push

- delete(value)：存在即删除集合中value

- has(value)：判断集合中是否存在 value

- clear()：清空集合

  ------

  ```javascript
  let set = new Set()
  set.add(1).add(2).add(1)
  
  set.has(1)	// true
  set.has(3)	// false
  set.delete(1)	
  set.has(1)	// false
  ```

  `Array.from` 方法可以将 Set 结构转为数组

  ```javascript
  const items = new Set([1, 2, 3, 2])
  const array = Array.from(items)
  console.log(array)	// [1, 2, 3]
  // 或
  const arr = [...items]
  console.log(arr)	// [1, 2, 3]
  ```

#### 遍历方法

（遍历顺序为插入顺序）

- keys()：返回一个包含集合中所有键的迭代器

- values()：返回一个包含集合中所有值得迭代器

- entries()：返回一个包含Set对象中所有元素得键值对迭代器

- forEach(callbackFn, thisArg)：用于对集合成员执行callbackFn操作，如果提供了 thisArg 参数，回调中的this会是这个参数，**没有返回值**

  ```javascript
  let set = new Set([1, 2, 3])
  console.log(set.keys())	// SetIterator {1, 2, 3}
  console.log(set.values())	// SetIterator {1, 2, 3}
  console.log(set.entries())	// SetIterator {1, 2, 3}
  
  for (let item of set.keys()) {
  	console.log(item);
  }	// 1	2	 3
  for (let item of set.entries()) {
  	console.log(item);
  }	// [1, 1]	[2, 2]	[3, 3]
  
  set.forEach((value, key) => {
  	console.log(key + ' : ' + value)
  })	// 1 : 1	2 : 2	3 : 3
  console.log([...set])	// [1, 2, 3]
  ```

  Set 可默认遍历，默认迭代器生成函数是 values() 方法

  ```javascript
  Set.prototype[Symbol.iterator] === Set.prototype.values	// true
  ```

  所以， Set可以使用 map、filter 方法

  ```javascript
  let set = new Set([1, 2, 3])
  set = new Set([...set].map(item => item * 2))
  console.log([...set])	// [2, 4, 6]
  
  set = new Set([...set].filter(item => (item >= 4)))
  console.log([...set])	//[4, 6]
  ```

  因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）

  ```javascript
  let set1 = new Set([1, 2, 3])
  let set2 = new Set([4, 3, 2])
  
  let intersect = new Set([...set1].filter(value => set2.has(value)))
  let union = new Set([...set1, ...set2])
  let difference = new Set([...set1].filter(value => !set2.has(value)))
  
  console.log(intersect)	// Set {2, 3}
  console.log(union)		// Set {1, 2, 3, 4}
  console.log(difference)	// Set {1}
  ```

## WeakSet

WeakSet 对象允许你将**弱引用对象**储存在一个集合中

WeakSet 与 Set 的区别：

- WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以
- WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素

### 属性：

- constructor：构造函数，任何一个具有 Iterable 接口的对象，都可以作参数

  ```
  const arr = [[1, 2], [3, 4]]
  const weakset = new WeakSet(arr)
  console.log(weakset)
  ```

[![2019-03-08 9 24 34](https://user-images.githubusercontent.com/19721451/54000884-27290900-4184-11e9-92f0-4d19ac6d080b.png)](https://user-images.githubusercontent.com/19721451/54000884-27290900-4184-11e9-92f0-4d19ac6d080b.png)

### 方法：

#### add(value)：

在WeakSet 对象中添加一个元素value

#### has(value)：

判断 WeakSet 对象中是否包含value

#### delete(value)：

删除元素 value

~~clear()：清空所有元素，**注意该方法已废弃**~~

```
var ws = new WeakSet()
var obj = {}
var foo = {}

ws.add(window)
ws.add(obj)

ws.has(window)	// true
ws.has(foo)	// false

ws.delete(window)	// true
ws.has(window)	// false
```



## Map  

集合 与 字典 的区别：

- 共同点：集合、字典 可以储存不重复的值

- 不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存

  

对象是创建无序键 / 值对数据结构 [ 也称为映射（map） ] 的主要机制。但是，对象作为映射的主要缺点是不能使用非字符串值作为键。  

在 ES6 中  需要使用 Map(..):

```javascript
var m = new Map():
var x = { id: 1 },
y = { id: 2 };
m.set( x, "foo" );
m.set( y, "bar" );
m.get( x ); // "foo"
m.get( y ); // "bar"
```

这里唯一的缺点就是不能使用方括号 [ ] 语法设置和获取值，但完全可以使用 get(..) 和set(..) 方法完美代替。 

### 方法

#### 操作方法：

- set(key, value)：向字典中添加新元素
- get(key)：通过键查找特定的数值并返回
- has(key)：判断字典中是否存在键key
- delete(key)：通过键 key 从字典中移除对应的数据
- clear()：将这个字典中的所有元素删除

#### 遍历方法

- Keys()：将字典中包含的所有键名以迭代器形式返回
- values()：将字典中包含的所有数值以迭代器形式返回
- entries()：返回所有成员的迭代器
- forEach()：遍历字典的所有成员

### Map 值  

- values(..)  
- Array.from(..)   
- entries()   

```javascript
var m = new Map();
var x = { id: 1 },
y = { id: 2 };
m.set( x, "foo" );
m.set( y, "bar" );
var vals = [ ...m.values() ];
vals; // ["foo","bar"]
Array.from( m.values() ); // ["foo","bar"]  
```

在一个 map 的项目上使用 entries() 迭代  

```javascript
考虑：
var m = new Map();
var x = { id: 1 },
y = { id: 2 };
m.set( x, "foo" );
m.set( y, "bar" );
var vals = [ ...m.entries() ];
vals[0][0] === x; // true
vals[0][1]; // "foo"
vals[1][0] === y; // true
vals[1][1]; // "bar"
```

### Map 键  

要得到一列键，可以使用 keys()，它会返回 map 中键上的迭代器：  

```javascript
var m = new Map();
var x = { id: 1 },
y = { id: 2 };
m.set( x, "foo" );
m.set( y, "bar" );

var keys = [ ...m.keys() ];

keys[0] === x; // true
keys[1] === y; // true
```

要确定一个 map 中是否有给定的键，可以使用 has(..) 方法：

```javascript
var m = new Map();
var x = { id: 1 },
y = { id: 2 };
m.set( x, "foo" );
m.has( x ); // true
m.has( y ); // false  
```

### **数据结构的相互转换**

1. Map 转 Array

   ```javascript
   const map = new Map([[1, 1], [2, 2], [3, 3]])
   console.log([...map])	// [[1, 1], [2, 2], [3, 3]]
   ```

2. Array 转 Map

   ```javascript
   const map = new Map([[1, 1], [2, 2], [3, 3]])
   console.log(map)	// Map {1 => 1, 2 => 2, 3 => 3}
   ```

3. Map 转 Object

   因为 Object 的键名都为字符串，而Map 的键名为对象，所以转换的时候会把非字符串键名转换为字符串键名。

   ```javascript
   function mapToObj(map) {
       let obj = Object.create(null)
       for (let [key, value] of map) {
           obj[key] = value
       }
       return obj
   }
   const map = new Map().set('name', 'An').set('des', 'JS')
   mapToObj(map)  // {name: "An", des: "JS"}
   ```

4. Object 转 Map

   ```javascript
   function objToMap(obj) {
       let map = new Map()
       for (let key of Object.keys(obj)) {
           map.set(key, obj[key])
       }
       return map
   }
   
   objToMap({'name': 'An', 'des': 'JS'}) // Map {"name" => "An", "des" => "JS"}
   ```

5. Map 转 JSON

   ```javascript
   function mapToJson(map) {
       return JSON.stringify([...map])
   }
   
   let map = new Map().set('name', 'An').set('des', 'JS')
   mapToJson(map)	// [["name","An"],["des","JS"]]
   ```

6. JSON 转 Map

   ```javascript
   function jsonToStrMap(jsonStr) {
     return objToMap(JSON.parse(jsonStr));
   }
   
   jsonToStrMap('{"name": "An", "des": "JS"}') // Map {"name" => "An", "des" => "JS"}
   ```

## WeakMap

WeakMap 对象是一组键值对的集合，其中的**键是弱引用对象，而值可以是任意**。

**注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。**

WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。

### 属性：

- constructor：构造函数

### 方法：

#### has(key)：

判断是否有 key 关联对象

#### get(key)：

返回key关联对象（没有则则返回 undefined）

#### set(key)：

设置一组key关联对象

#### delete(key)：

移除 key 的关联对象

```
let myElement = document.getElementById('logo');
let myWeakmap = new WeakMap();

myWeakmap.set(myElement, {timesClicked: 0});

myElement.addEventListener('click', function() {
  let logoData = myWeakmap.get(myElement);
  logoData.timesClicked++;
}, false);
```

## 总结

- Set
  - 成员唯一、无序且不重复
  - [value, value]，键值与键名是一致的（或者说只有键值，没有键名）
  - 可以遍历，方法有：add、delete、has
- WeakSet
  - 成员都是对象
  - 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏
  - 不能遍历，方法有add、delete、has
- Map
  - 本质上是键值对的集合，类似集合
  - 可以遍历，方法很多可以跟各种数据格式转换
- WeakMap
  - 只接受对象作为键名（null除外），不接受其他类型的值作为键名
  - 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
  - 不能遍历，方法有get、set、has、delete

## 扩展：Object与Set、Map

1. Object 与 Set

   ```
   // Object
   const properties1 = {
       'width': 1,
       'height': 1
   }
   console.log(properties1['width']? true: false) // true
   
   // Set
   const properties2 = new Set()
   properties2.add('width')
   properties2.add('height')
   console.log(properties2.has('width')) // true
   ```

2. Object 与 Map

   JS 中的对象（Object），本质上是键值对的集合（hash 结构）

   ```
   const data = {};
   const element = document.getElementsByClassName('App');
   
   data[element] = 'metadata';
   console.log(data['[object HTMLCollection]']) // "metadata"
   ```

   但当以一个DOM节点作为对象 data 的键，对象会被自动转化为字符串[Object HTMLCollection]，所以说，Object 结构提供了 **字符串-值** 对应，Map则提供了 **值-值** 的对应

