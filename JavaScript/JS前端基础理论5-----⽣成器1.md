# JS前端基础理论-----⽣成器

生成器是一种返回迭代器的函数，**通过function关键字后的星号(*)来表示，函数中会用到新的关键字yield。星号可以紧挨着function关键字，也可以在中间添加一个空格**

看似同步的异步流程控制表达⻛格。使这种⻛格成为可能的“魔法”就是 ES6 ⽣成器 （generator）  

yield/next(..) 这⼀对不只是⼀种控制机制，实际上也是⼀种双向消息传递机制。yield .. 表达式本质上是暂停下来等待某个值，接下来的 next(..) 调⽤会向被暂停的 yield 表达式传回⼀个值（或者是隐式的 undefined ）。

在异步控制流程⽅⾯，⽣成器的关键优点是：⽣成器内部的代码是以⾃然的同步 / 顺序⽅式表达任务的⼀系列步骤。其技巧在于，我们把可能的异步隐藏在了关键字 yield 的后⾯，把异步移动到控制⽣成器的迭代器的代码部分。

换句话说，⽣成器为异步代码保持了顺序、同步、阻塞的代码模式，这使得⼤脑可以更⾃然地追踪代码，解决了基于回调的异步的两个关键缺陷之⼀。  

## 打破完整运⾏  

下⾯是实现这样的合作式并发的 ES6 代码：

```javascript
var x = 1;
function *foo() {
    x++;
    yield; // 暂停！
    console.log( "x:", x );
}
function bar() {
	x++;
}  
```

> 很可能你看到的其他多数 JavaScript ⽂档和代码中的⽣成器声明格式都是 function* foo() { .. } ，⽽不是我这⾥使⽤的 function *foo() { .. } ：唯⼀区别是 * 位置的⻛格不同。这两种形式在功能和语法上都是等同的，还有⼀种是function*foo(){ .. } （没有空格）也⼀样。两种⻛格，各有优缺，但总体上我⽐较喜欢 function *foo.. 的形式，因为这样在使⽤ *foo() 来引⽤⽣成器的时候就会⽐较⼀致。如果只⽤ foo() 的形式，你就不会清楚知道我指的是⽣成器还是常规函数。这完全是⼀个⻛格偏好问题。  

现在，我们要如何运⾏前⾯的代码⽚段，使得 bar() 在 *foo() 内部的 yield 处执⾏呢？

```javascript
// 构造⼀个迭代器it来控制这个⽣成器
var it = foo();
// 这⾥启动foo()！
it.next();
x; // 2
bar();
x; // 3
it.next(); // x: 3  
```

在解释 ES6 ⽣成器的不同机制和语法之前，我们先来看看运⾏过程。

1. it = foo() 运算并没有执⾏⽣成器 *foo() ，⽽只是构造了⼀个迭代器 （iterator），这个迭代器会控制它的执⾏。后⾯会介绍迭代器。
2. 第⼀个 it.next() 启动了⽣成器 *foo() ，并运⾏了 *foo()第⼀⾏的 x++ 。
3. *foo() 在 yield 语句处暂停，在这⼀点上第⼀个 it.next()调⽤结束。此时 *foo() 仍在运⾏并且是活跃的，但处于暂停状态。
4. 我们查看 x 的值，此时为 2 。
5. 我们调⽤ bar() ，它通过 x++ 再次递增 x 。
6. 我们再次查看 x 的值，此时为 3 。
7. 最后的 it.next() 调⽤从暂停处恢复了⽣成器 *foo() 的执⾏，并运⾏ console.log(..) 语句，这条语句使⽤当前 x 的值 3 。显然，foo() 启动了，但是没有完整运⾏，它在 yield 处暂停了。后⾯恢复了 foo() 并让它运⾏到结束，但这不是必需的。

因此，⽣成器就是⼀类特殊的函数，可以⼀次或多次启动和停⽌，并不⼀定⾮得要完成。

### 输⼊和输出  

1. 迭代消息传递  

   ⽣成器甚⾄提供了更强⼤更引⼈注⽬的内建消息输⼊输出能⼒，通过 yield 和 next(..) 实现。 

    考虑：

   ```javascript
   function *foo(x) {
       var y = x * (yield);
       return y;
   }
   
   var it = foo( 6 );
   
   // 启动foo(..)
   it.next();
   
   var res = it.next( 7 );
   res.value; // 42
   ```

   ⾸先，传⼊ 6 作为参数 x 。然后调⽤ it.next() ，这会启动*foo(..) 。

   在 *foo(..) 内部，开始执⾏语句 var y = x .. ，但随后就遇到了⼀个 yield 表达式。它就会在这⼀点上暂停 *foo(..) （在赋值语句中间！），并在本质上要求调⽤代码为 yield 表达式提供⼀个结果值。接下来，调⽤ it.next( 7 ) ，这⼀句把值 7 传回作为被暂停的 yield 表达式的结果。

   所以，这时赋值语句实际上就是 var y = 6 * 7 。现在，return y返回值 42 作为调⽤ it.next( 7 ) 的结果。 

    

   - **迷惑性：**

   根据你的视⾓不同，yield 和 next(..) 调⽤有⼀个不匹配。⼀般来说，需要的 next(..) 调⽤要⽐ yield 语句多⼀个，前⾯的代码⽚段有⼀个 yield 和两个 next(..) 调⽤。为什么会有这个不匹配？

   因为第⼀个 next(..) 总是启动⼀个⽣成器，并运⾏到第⼀个 yield处。不过，是第⼆个 next(..) 调⽤完成第⼀个被暂停的 yield 表达式，第三个 next(..) 调⽤完成第⼆个 yield ，以此类推。  

   

2. 两个问题的故事

   

   - 消息是双向传递的

   ——yield.. 作为⼀个表达式可以发出消息响应 next(..) 调⽤，next(..) 也可以向暂停的 yield 表达式发送值。考虑下⾯这段稍稍调整过的代码：

   ```javascript
   function *foo(x) {
       var y = x * (yield "Hello"); // <-- yield⼀个值！
       return y;
   }
   
   var it = foo( 6 );
   
   var res = it.next(); // 第⼀个next()，并不传⼊任何东⻄
   res.value; // "Hello"
   
   res = it.next( 7 ); // 向等待的yield传⼊7
   res.value; // 42
   ```

   yield .. 和 next(..) 这⼀对组合起来，在⽣成器的执⾏过程中构成了⼀个双向消息传递系统。

   那么只看下⾯这⼀段迭代器 代码：

   ```javascript
   var res = it.next(); // 第⼀个next()，并不传⼊任何东⻄
   res.value; // "Hello"
   res = it.next( 7 ); // 向等待的yield传⼊7
   res.value; // 42
   ```

   > 我们并没有向第⼀个 next() 调⽤发送值，这是有意为之。只有暂停的 yield 才能接受这样⼀个通过 next(..) 传递的值，⽽在⽣成器的起始处我们调⽤第⼀个 next() 时，还没有暂停的 yield 来接受这样⼀个值。规范和所有兼容浏览器都会默默丢弃传递给第⼀个 next() 的任何东⻄。传值过去仍然不是⼀个好思路，因为你创建了沉默的⽆效代码，这会让⼈迷惑。因此，启动⽣成器时⼀定要⽤不带参数的 next() 。

   第⼀个 next() 调⽤（没有参数的）基本上就是在提出⼀个问题：“⽣成器 *foo(..) 要给我的下⼀个值是什么”。谁来回答这个问题呢？第⼀个 yield "hello" 表达式。

   看⻅了吗？这⾥没有不匹配。

   根据你认为提出问题的是谁，yield 和 next(..) 调⽤之间要么有不匹配，要么没有。

   但是，稍等！与 yield 语句的数量相⽐，还是多出了⼀个额外的next() 。所以，最后⼀个 it.next(7) 调⽤再次提出了这样的问题：⽣成器将要产⽣的下⼀个值是什么。但是，再没有 yield 语句来回答这个问题了，是不是？那么谁来回答呢？

   return 语句回答这个问题！

   如果你的⽣成器中没有 return 的话——在⽣成器中和在普通函数中⼀样，return 当然不是必需的——总有⼀个假定的 / 隐式的return; （也就是 return undefined; ），它会在默认情况下回答最后的 it.next(7) 调⽤提出的问题。

   这样的提问和回答是⾮常强⼤的：通过 yield 和 next(..) 建⽴的双向消息传递。但⽬前还不清楚这些机制是如何与异步流程控制联系到⼀起的。会清楚的！  

### 多个迭代器  

同⼀个⽣成器的多个实例可以同时运⾏，它们甚⾄可以彼此交互：  

```javascript
function *foo() {
    var x = yield 2;
    z++;
    var y = yield (x * z);
    console.log( x, y, z );
}
var z = 1;

var it1 = foo();
var it2 = foo();

var val1 = it1.next().value; // 2 <-- yield 2
var val2 = it2.next().value; // 2 <-- yield 2

val1 = it1.next( val2 * 10 ).value; // 40 <-- x:20, z:2
val2 = it2.next( val1 * 5 ).value; // 600 <-- x:200, z:3

it1.next( val2 / 2 ); 	// y:300
						// 20 300 3
it2.next( val1 / 4 ); 	// y:10
						// 200 10 3
```

同⼀个⽣成器的多个实例并发运⾏的最常⽤处并不是这样
的交互，⽽是⽣成器在没有输⼊的情况下，可能从某个独⽴连接
的资源产⽣⾃⼰的值。下⼀节中我们会详细介绍值产⽣。

我们简单梳理⼀下执⾏流程。

1. *foo() 的两个实例同时启动，两个 next() 分别从 yield 2 语句得到值 2 。
2. val2 * 10 也就是 2 * 10 ，发送到第⼀个⽣成器实例 it1 ，因此 x 得到值 20 。z 从 1 增加到 2 ，然后 20 * 2 通过 yield 发出，将 val1 设置为 40 。
3. val1 * 5 也就是 40 * 5 ，发送到第⼆个⽣成器实例 it2 ，因此 x 得到值 200 。z 再次从 2 递增到 3 ，然后 200 * 3 通过 yield发出，将 val2 设置为 600 。
4. val2 / 2 也就是 600 / 2 ，发送到第⼀个⽣成器实例 it1 ，因此 y 得到值 300 ，然后打印出 x y z 的值分别是 20 300 3 。
5. val1 / 4 也就是 40 / 4 ，发送到第⼆个⽣成器实例 it2 ，因此 y 得到值 10 ，然后打印出 x y z 的值分别为 200 10 3 。

在脑海中运⾏⼀遍这个例⼦很有趣。理清楚了吗？

#### 交替执⾏  

```javascript
var a = 1;
var b = 2;
function *foo() {
    a++;
    yield;
    b = b * a;
    a = (yield b) + 3;
}
function *bar() {
    b--;
    yield;
    a = (yield 8) + b;
    b = a * (yield 2);
}  
```

构建⼀个名为 step(..) 的辅助函数，⽤于控制迭代器 ：  

```javascript
function step(gen) {
    var it = gen();
    var last;
    return function() {
        // 不管yield出来的是什么，下⼀次都把它原样传回去！
        last = it.next( last ).value;
    };
}  
```

step(..) 初始化了⼀个⽣成器来创建迭代器 it ，然后返回⼀个函
数，这个函数被调⽤的时候会将迭代器 向前迭代⼀步。另外，前⾯的
yield 发出的值会在下⼀步发送回去。于是，yield 8 就是 8 ，⽽
yield b 就是 b （yield 发出时的值）。  

```javascript
// 确保重新设置a和b
a = 1;
b = 2;
var s1 = step( foo );
var s2 = step( bar );

// ⾸次运⾏*foo()
s1();
s1();
s1();

// 现在运⾏*bar()
s2();
s2();
s2();
s2();
console.log( a, b ); // 11 22  
```

最后的结果是 11 和 22 ，和第 1 章中的版本⼀样。现在交替执⾏顺
序，看看 a 和 b 的值是如何改变的：

```javascript
// 确保重新设置a和b
a = 1;
b = 2;
var s1 = step( foo );
var s2 = step( bar );
s2(); // b--;
s2(); // yield 8
s1(); // a++;
s2(); // a = 8 + b;

// yield 2
s1(); // b = b * a;

// yield b
s1(); // a = b + 3;
s2(); // b = a * 2;
```

在告诉你结果之前，你能推断出前⾯的程序运⾏后 a 和 b 的值吗？不
要作弊！

```javascript
console.log( a, b ); // 12 18
```

## ⽣成器产⽣值    

### ⽣产者与迭代器-----非生成器使用迭代

迭代器 是⼀个定义良好的接⼝，⽤于从⼀个⽣产者⼀步步得到⼀系列值  

可以为我们的数字序列⽣成器实现标准的迭代器 接⼝：

```javascript
var something = (function(){
    var nextVal;
    return {
        // for..of循环需要
        [Symbol.iterator]: function(){ return this; },
        // 标准迭代器接⼝⽅法
        next: function(){
            if (nextVal === undefined) {
            	nextVal = 1;
            }
            else {
            	nextVal = (3 * nextVal) + 6;
            }
            return { done:false, value:nextVal };
        }
    };
})();
something.next().value; // 1
something.next().value; // 9
something.next().value; // 33
something.next().value; // 105
```

> 我们将在 4.2.2 节解释为什么在这段代码中需要[Symbol.iterator]: .. 这⼀部分。
>
> - 从语法上说，这涉及了两个 ES6 特性。这在对象术语定义中是指，指定⼀个表达式并⽤这个表达式的结果作为属性的名称。
> - 另外，Symbol.iterator 是ES6 预定义的特殊 Symbol 值之⼀。  

ES6 还新增了⼀个 for..of 循环，这意味着可以通过原⽣循环语法⾃动迭代标准迭代器 ：

```javascript
for (var v of something) {
    console.log( v );
    // 不要死循环！
    if (v > 500) {
    	break;
    }
}
// 1 9 33 105 321 969  
```

因为我们的迭代器 something 总是返回 done:false ，因此这个 for..of 循环将永远运⾏下去，这也就是为什么我们要在⾥⾯放⼀个 break 条件。迭代器永不结束是完全没问题的，但是也有⼀些情况下，迭代器 会在有限的值集合上运⾏，并最终返回 done:true 。

for..of 循环在每次迭代中⾃动调⽤ next() ，它不会向 next()传⼊任何值，并且会在接收到 done:true 之后⾃动停⽌。这对于在⼀组数据上循环很⽅便。  

当然，也可以⼿⼯在迭代器上循环，调⽤ next() 并检查done:true 条件来确定何时停⽌循环：

```javascript
for (
var ret;
(ret = something.next()) && !ret.done;
) {
    console.log( ret.value );
    // 不要死循环！
    if (ret.value > 500) {
    	break;
    }
}
// 1 9 33 105 321 969
```

这种**⼿⼯ for ⽅法当然要⽐ ES6 的 for..of 循环语法丑陋，但其优点是，这样就可以在需要时向 next() 传递值**。  

### iterable  

something 对象叫作迭代器 ，因为它的接⼝中有⼀个next() ⽅法。⽽与其紧密相关的⼀个术语是 iterable（可迭代），即指⼀个包含可以在其值上迭代的迭代器的对象。  

从 ES6 开始，从⼀个 iterable 中提取迭代器的⽅法是：iterable 必须⽀持⼀个函数，其名称是专门的 ES6 符号值 Symbol.iterator 。调⽤这个函数时，它会返回⼀个迭代器。通常每次调⽤会返回⼀个全新的迭代器，虽然这⼀点并不是必须的。

前⾯代码⽚段中的 a 就是⼀个 iterable。for..of 循环⾃动调⽤它的Symbol.iterator 函数来构建⼀个迭代器。我们当然也可以⼿⼯调⽤这个函数，然后使⽤它返回的迭代器：  

```javascript
var a = [1,3,5,7,9];
var it = a[Symbol.iterator]();
it.next().value; // 1
it.next().value; // 3
it.next().value; // 5
..
```

前⾯的代码中列出了定义的 something ，你可能已经注意到了这⼀⾏：

```javascript
[Symbol.iterator]: function(){ return this; }
```

这段有点令⼈疑惑的代码是在将 something 的值（迭代器something 的接⼝）也构建成为⼀个 iterable。现在它既是iterable，也是迭代器。然后我们把 something 传给 for..of 循环：

```javascript
for (var v of something) {
	..
}
```

for..of 循环期望 something 是 iterable，于是它寻找并调⽤它的Symbol.iterator 函数。我们将这个函数定义为就是简单的return this ，也就是把⾃⾝返回，⽽ for..of 循环并不知情。  

### ⽣成器迭代器  

严格说来，⽣成器本⾝并不是 iterable，尽管⾮常类似——当你执⾏⼀个⽣成器，就得到了⼀个迭代器：  

可以通过⽣成器实现前⾯的这个 something ⽆限数字序列⽣产者，
类似这样：

```javascript
function *something() {
    var nextVal;
    
    while (true) {
        if (nextVal === undefined) {
        	nextVal = 1;
        }
        else {
        	nextVal = (3 * nextVal) + 6;
        }
        yield nextVal;
    }
}  
```

> 通常在实际的 JavaScript 程序中使⽤ while..true 循环是⾮常糟糕的主意，⾄少如果其中没有 break 或 return 的话是这样，因为它有可能会同步地⽆限循环，并阻塞和锁住浏览器UI。
>
> 但是，*如果在⽣成器中有 yield 的话，使⽤这样的循环就完全没有问题。*因为⽣成器会在每次迭代中暂停，通过 yield 返回到主程序或事件循环队列中。简单地说就是：“⽣成器把while..true 带回了 JavaScript 编程的世界！  

⽣成器会在每个 yield 处暂停，函数 *something() 的状态（作⽤域）会被保持，即意味着不需要闭包在调⽤之间保持变量状态。  

现在，可以通过 for..of 循环使⽤我们雕琢过的新的*something() ⽣成器。你可以看到，其⼯作⽅式基本是相同的：

```javascript
for (var v of something()) {
    console.log( v );
    // 不要死循环！
    if (v > 500) {
    	break;
    }
}
// 1 9 33 105 321 969
```

但是，不要忽略了这段 for (var v of something()) .. ！我们并不是像前⾯的例⼦那样把 something 当作⼀个值来引⽤，⽽是调⽤了 *something() ⽣成器以得到它的迭代器供 for..of 循环使⽤。  

如果认真思考的话，你也许会从这段⽣成器与循环的交互中提出两个
问题。

- 为什么不能⽤ for (var v of something) .. ？因为这⾥的 something 是⽣成器，并不是 iterable。我们需要调⽤something() 来构造⼀个⽣产者供 for..of 循环迭代。
- something() 调⽤产⽣⼀个迭代器，但 for..of 循环需要的是⼀个 iterable，对吧？是的。⽣成器的迭代器也有⼀个Symbol.iterator 函数，基本上这个函数做的就是 returnthis ，和我们前⾯定义的 iterable something ⼀样。换句话说，⽣成器的迭代器也是⼀个 iterable ！  

#### 停⽌⽣成器  

在前⾯的例⼦中，看起来似乎 *something() ⽣成器的迭代器实例在循环中的 break 调⽤之后就永远留在了挂起状态。

其实有⼀个隐藏的特性会帮助你管理此事。for..of 循环的“异常结束”（也就是“提前终⽌”），通常由 break 、return 或者未捕获异常引起，会向⽣成器的迭代器发送⼀个信号使其终⽌。  

如果在⽣成器内有 try..finally 语句，它将总是运⾏，即使⽣成器已经外部结束。如果需要清理资源的话（数据库连接等），这⼀点⾮常有⽤：

```javascript
function *something() {
    try {
        var nextVal;
        while (true) {
            if (nextVal === undefined) {
            	nextVal = 1;
            }
            else {
            	nextVal = (3 * nextVal) + 6;
            }
            yield nextVal;
        }
    }
    // 清理⼦句
    finally {
    	console.log( "cleaning up!" );
    }
} 
```

之前的例⼦中，for..of 循环内的 break 会触发 finally 语句。但是，也可以在外部通过 return(..) ⼿⼯终⽌⽣成器的迭代器实例：

```javascript
var it = something();
for (var v of it) {
    console.log( v );
    // 不要死循环！
    if (v > 500) {
        console.log(
            // 完成⽣成器的迭代器
            it.return( "Hello World" ).value
        );
        // 这⾥不需要break
    }
}
// 1 9 33 105 321 969
// 清理！
// Hello World
```

调⽤ it.return(..) 之后，它会⽴即终⽌⽣成器，这当然会运⾏finally 语句。另外，它还会把返回的 value 设置为传⼊return(..) 的内 容，这也就是 "Hello World" 被传出去的过程。现在我们也不需要包含 break 语句了，因为⽣成器的迭代器已经被设置为 done:true ，所以 for..of 循环会在下⼀个迭代终⽌  

## 异步迭代⽣成器  

通过⽣成器来表达同样的任务流程控制，可以这样实现：

```javascript
function foo(x,y) {
    ajax(
        "http://some.url.1/?x=" + x + "&y=" + y,
        function(err,data){
            if (err) {
                // 向*main()抛出⼀个错误
                it.throw( err );
            }
            else {
                // ⽤收到的data恢复*main()
                it.next( data );
            }
        }
    );
}
function *main() {
    try {
        var text = yield foo( 11, 31 );
        console.log( text );
    }
    catch (err) {
    	console.error( err );
    }
}
var it = main();
// 这⾥启动！
it.next();
```

这⾥并不是在消息传递的意义上使⽤ yield ，⽽只是将其⽤于流程控制实现暂停 / 阻塞。实际上，它还是会有消息传递，但只是⽣成器恢复运⾏之后的单向消息传递。  

把异步作为实现细节抽象了出去，使得我们可以以同步顺序的形式追踪流程控制：“发出⼀个 Ajax 请求，等它完成之后打印出响应结果。”并且，当然，我们只在这个流程控制中表达了两个步骤，⽽这种表达能⼒是可以⽆限扩展的，以便我们⽆论需要多少步骤都可以表达。  

### 同步错误处理  

```javascript
try {
    var text = yield foo( 11, 31 );
    console.log( text );
}
catch (err) {
	console.error( err );
}  
```

我们已经看到 yield 是如何让赋值语句暂停来等待 foo(..) 完成，使得响应完成后可以被赋给 text 。精彩的部分在于 yield 暂停也使得⽣成器能够捕获错误。通过这段前⾯列出的代码把错误抛出到⽣成器中：

```javascript
if (err) {
    // 向*main()抛出⼀个错误
    it.throw( err );
} 
```

⽣成器 yield 暂停的特性意味着我们不仅能够从异步函数调⽤得到看似同步的返回值，还可以同步捕获来⾃这些异步函数调⽤的错误！  

可以捕获通过 throw(..) 抛⼊⽣成器的同⼀个错误，基本上也就是给⽣成器⼀个处理它的机会；如果没有处理的话，迭代器代码就必须处理：

```javascript
function *main() {
    var x = yield "Hello World";
    // 永远不会到达这⾥
    console.log( x );
}

var it = main();
it.next();

try {
    // *main()会处理这个错误吗？看看吧！
    it.throw( "Oops" );
}
catch (err) {
    // 不⾏，没有处理！
    console.error( err ); // Oops
} 
```

在异步代码中实现看似同步的错误处理（通过 try..catch ）在可读性和合理性⽅⾯都是⼀个巨⼤的进步。 
