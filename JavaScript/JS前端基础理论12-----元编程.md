# JS前端基础理论-----元编程

## 函数名称  

ES6 中名称推导（或者没有名称）的其他几种形式：

```javascript
(function(){ .. }); // name:
(function*(){ .. }); // name:
window.foo = function(){ .. }; // name:
class Awesome {
    constructor() { .. } // name: Awesome
    funny() { .. } // name: funny
}
var c = class Awesome { .. }; // name: Awesome
var o = {
    foo() { .. }, // name: foo
    *bar() { .. }, // name: bar
    baz: () => { .. }, // name: baz
    bam: function(){ .. }, // name: bam
    get qux() { .. }, // name: get qux
    set fuz() { .. }, // name: set fuz
    ["b" + "iz"]:
    	function(){ .. }, // name: biz
    [Symbol( "buz" )]:
    	function(){ .. } // name: [buz]
};
var x = o.foo.bind( o ); // name: bound foo
(function(){ .. }).bind( o ); // name: bound  

export default function() { .. } // name: default
var y = new Function(); // name: anonymous
var GeneratorFunction =
	function*(){}.__proto__.constructor;
var z = new GeneratorFunction(); // name: anonymous
```

默认情况下， name 属性不可写，但可配置，也就是说如果需要的话，可使用 Object.defineProperty(..) 来手动修改。  

## 元属性  

> 对于所有的元编程技术都要小心，不要编写过于机灵的代码，让未来的你或者其他代码维护者难以理解。要小心使用这些技巧。  

```javascript
class Parent {
    constructor() {
        if (new.target === Parent) {
        	console.log( "Parent instantiated" );
        }
        else {
        	console.log( "A child instantiated" );
        }
    }
}
class Child extends Parent {}

var a = new Parent();
// Parent instantiated

var b = new Child();
// A child instantiated  
```

## 公开符号  

### Symbol.iterator  

功能：给 ... 展开和 for..of 循环自动使用的  

Symbol.iterator 特点

- 表示任意对象上的一个专门位置（属性），语言机制自动在这个位置上寻找一个方法，这个方法构造一个迭代器来消耗这个对象的值。
- 很多对象定义有这个符号的默认值。  
- 通过定义 Symbol.iterator 属性为任意对象值定义自己的迭代器逻辑 这会覆盖默认的迭代器。  

考虑：

```javascript
var arr = [4,5,6,7,8,9];
for (var v of arr) {
	console.log( v );
}
// 4 5 6 7 8 9
// 定义一个只在奇数索引值产生值的迭代器
arr[Symbol.iterator] = function*() {
    var idx = 1;
    do {
    	yield this[idx];
    } while ((idx += 2) < this.length);
};
for (var v of arr) {  
	console.log( v );
}
// 5 7 9  
```

### Symbol.toStringTag 与 Symbol.hasInstance  

在一个值上进行内省来找出它是什么种类，这通常是为了确定其上适合执行何种运算。  

- 原型（或实例本身）的 @@toStringTag 符号指定了在 [object ___] 字符串化时使用的字符串值。
- @@hasInstance 符号是在构造器函数上的一个方法，接受实例对象值，通过返回 true 或false 来指示这个值是否可以被认为是一个实例。  

在 ES6 中，可以控制这些操作的行为特性：

```javascript
function Foo(greeting) {
	this.greeting = greeting;
}
Foo.prototype[Symbol.toStringTag] = "Foo";
Object.defineProperty( Foo, Symbol.hasInstance, {
    value: function(inst) {
    	return inst.greeting == "hello";
    }
} );
var a = new Foo( "hello" ),
b = new Foo( "world" );
b[Symbol.toStringTag] = "cool";
a.toString(); // [object Foo]
String( b ); // [object cool]
a instanceof Foo; // true
b instanceof Foo; // false  
```

### Symbol.species  

我们介绍了符号 @@species，这个符号控制要生成新实例时，类的内置方法使用哪一个构造器。  

但是，你可以通过覆盖一个类的默认 @@species 定义来进行元编程：

```javascript
class Cool {
    // 把@@species推迟到子类
    static get [Symbol.species]() { return this; }
    again() {
    	return new this.constructor[Symbol.species]();
    }
}
class Fun extends Cool {}
class Awesome extends Cool {
    // 强制指定@@species为父构造器
    static get [Symbol.species]() { return Cool; }
}
var a = new Fun(),
b = new Awesome(),
c = a.again(),
d = b.again();
c instanceof Fun; // true
d instanceof Awesome; // false
d instanceof Cool; // true
```

就像前面代码中 Cool 的定义那样，内置原生构造器上 Symbol.species 的默认行为是return this。在用户类上没有默认值，但是就像展示的那样，这个行为特性很容易模拟。

如果需要定义生成新实例的方法，使用 new this.constructor[Symbol.species](..) 模式元编程，而不要硬编码 new this.constructor(..) 或 new XYZ(..)。然后继承类就能够自定义 Symbol.species 来控制由哪个构造器产生这些实例。  

### Symbol.toPrimitive  

抽象类型转换运算ToPrimitive，它用在对象为了某个操作（比如比较 == 或者相加 +）必须被强制转换为一个原生类型值的时候。在 ES6 之前，没有办法控制这一行为。  

而在 ES6 中，在任意对象值上作为属性的符号 @@toPrimitivesymbol 都可以通过指定一个方法来定制这个 ToPrimitive 强制转换。  

考虑：

```javascript
var arr = [1,2,3,4,5];
arr + 10; // 1,2,3,4,510
arr[Symbol.toPrimitive] = function(hint) {
    if (hint == "default" || hint == "number") {
        // 求所有数字之和
        return this.reduce( function(acc,curr){
        	return acc + curr;
        }, 0 );
    }
};
arr + 10; // 25  
```

### 正则表达式符号  

@@match：  

@@replace  

@@search  

@@split  

如果你不够艺高人胆大的话，就不要覆盖内置正则表达式算法了！ JavaScript 的正则表达式引擎经过高度优化，所以你自己的用户代码很可能会慢上许多。这类元编程简洁强大，但是只应该在确实需要或能带来收益的时候才使用。  

### Symbol.isConcatSpreadable  

用来指示如果把它传给一个数组的 concat(..) 是否应该将其展开。

考虑：

```javascript
var a = [1,2,3],
b = [4,5,6];
b[Symbol.isConcatSpreadable] = false;
[].concat( a, b ); // [1,2,3,[4,5,6]]  
```

## 代理  

ES6 中新增的最明显的元编程特性之一是 Proxy（代理）特性。

代理是一种由你创建的特殊的对象，它“封装”另一个普通对象——或者说挡在这个普通对象的前面。你可以在代理对象上注册特殊的处理函数（也就是 trap），代理上执行各种操作的时候会调用这个程序。这些处理函数除了把操作转发给原始目标 / 被封装对象之外，还有机会执行额外的逻辑。

你可以在代理上定义的 trap 处理函数的一个例子是 get，当你试图访问对象属性的时候，它拦截 [[Get]] 运算。考虑：

```javascript
var obj = { a: 1 },
    handlers = {
        get(target,key,context) {
            // 注意： target === obj,
            // context === pobj
            console.log( "accessing: ", key );
            return Reflect.get(  
                target, key, context
            );
        }
    },
	pobj = new Proxy( obj, handlers );
	
obj.a;
// 1

pobj.a;
// accessing: a
// 1  
```

我们在 handlers（Proxy(..) 的第二个参数）对象上声明了一个 get(..) 处理函数命名方法，它接受一个 target 对象的引用（obj）、 key 属性名 ("a") 粗体文字以及 self/ 接收者 /代理（pobj）。

在跟踪语句 console.log(..) 之后，我们把对 obj 的操作通过 Reflect.get(..)“转发”。下一小节中会介绍 APIReflect，这里只要了解每个可用的代理 trap 都有一个对应的同名Reflect 函数即可。

这里的映射是有意对称的。每个代理处理函数在对应的元编程任务执行的时候进行拦截，而每个 Reflect 工具在一个对象上执行相应的元编程任务。每个代理处理函数都有一个自动调用相应的 Reflect 工具的默认定义。几乎可以确定 Proxy 和 Reflect 总是这么协同工作的。  

下面所列出的是在目标对象 / 函数代理上可以定义的处理函数，以及它们如何 / 何时被触发。

- get(..)
  通过 [[Get]]，在代理上访问一个属性（Reflect.get(..)、 . 属性运算符或 [ .. ] 属性运算符）
- set(..)
  通过 [[Set]]， 在代理上设置一个属性值（Reflect.set(..)、赋值运算符 = 或目标为对象属性的解构赋值）
- deleteProperty(..)
  通 过 [[Delete]]， 从 代 理 对 象 上 删 除 一 个 属 性（Reflect.deleteProperty(..) 或delete）
- apply(..)（如果目标为函数）
  通 过 [[Call]]， 将 代 理 作 为 普 通 函 数 / 方 法 调 用（Reflect.apply(..)、 call(..)、apply(..) 或 (..) 调用运算符）  
- construct(..)（如果目标为构造函数）
  通过 [[Construct]]， 将代理作为构造函数调用（Reflect.construct(..) 或 new）
- getOwnPropertyDescriptor(..)
  通过 [[GetOwnProperty]]，从代理中提取一个属性描述符（Object.getOwnPropertyDescriptor(..)或 Reflect.getOwnPropertyDescriptor(..)）
- defineProperty(..)
  通过 [[DefineOwnProperty]]，在代理上设置一个属性描述符（Object.defineProperty(..)或 Reflect.defineProperty(..)）
- getPrototypeOf(..)
  通 过 [[GetPrototypeOf]]， 得 到 代 理 的 [[Prototype]]（Object.getPrototypeOf(..)、Reflect.getPrototypeOf(..)、 __proto__、 Object#isPrototypeOf(..) 或 instanceof）
- setPrototypeOf(..)
  通 过 [[SetPrototypeOf]]， 设 置 代 理 的 [[Prototype]]（Object.setPrototypeOf(..)、Reflect.setPrototypeOf(..) 或 __proto__）
- preventExtensions(..)
  通过 [[PreventExtensions]]，使得代理变成不可扩展的（Object.prevent Extensions(..)或 Reflect.preventExtensions(..)）
- isExtensible(..)
  通过 [[IsExtensible]]，检测代理是否可扩展（Object.isExtensible(..) 或 Reflect.isExtensible(..)）
- ownKeys(..)
  通过 [[OwnPropertyKeys]]，提取代理自己的属性和 / 或符号属性（Object.keys(..)、Object.getOwnPropertyNames(..)、 Object.getOwnSymbolProperties(..)、 Reflect.ownKeys(..) 或 JSON.stringify(..)）
- enumerate(..)
  通过 [[Enumerate]]，取得代理拥有的和“继承来的”可枚举属性的迭代器（Reflect.enumerate(..) 或 for..in）
- has(..)
  通过 [[HasProperty]]，检查代理是否拥有或者“继承了”某个属性（Reflect.has(..)、Object#hasOwnProperty(..) 或 "prop" in obj）  



除了上面列出的会触发各种 trap 的动作，某些 trap 是由其他 trap 的默认动作间接触发的。
比如：

```javascript
var handlers = {
    getOwnPropertyDescriptor(target,prop) {
        console.log(
        	"getOwnPropertyDescriptor"
        );
        return Object.getOwnPropertyDescriptor(
        	target, prop
        );
    },
    defineProperty(target,prop,desc){
        console.log( "defineProperty" );
        return Object.defineProperty(
        	target, prop, desc
        );
    }
},
	proxy = new Proxy( {}, handlers );

proxy.a = 2;
// getOwnPropertyDescriptor
// defineProperty
```

getOwnPropertyDescriptor(..) 和 defineProperty(..) 处理函数是在设定属性值（不管是新增的还是更新已有的）时由默认 set(..) 处理函数的步骤触发的。如果你也自定义了set(..) 处理函数，那么在 context（不是 target ！）上可以（也可以不）进行相应的调用，这些调用会触发这些代理 trap。  

### 代理局限性  

代理处理函数总会有一些不变性（invariant），亦即不能被覆盖的行为。比如， isExtensible(..) 处理函数的返回值总会被类型转换为 boolean。这些不变性限制了自定义代理行为的能力，但它们的目的只是为了防止你创建诡异或罕见（或者不一致）的行为。这些不变性条件非常复杂，所以这里我们不会完整介绍，这篇文章（http://www.2ality.com/2014/12/es6-proxies.html#invariants）对此给出了很棒的介绍。  

```javascript
var obj = { a:1, b:2 },
    handlers = { .. },
    pobj = new Proxy( obj, handlers );
typeof obj;
String( obj );  
obj + "";
obj == pobj;
obj === pobj  
```

### 可取消代理  

可能会存在这样的情况，比如你想要创建一个在你想要停止它作为代理时便可以被停用的代理  

```javascript
var obj = { a: 1 },
handlers = {
    get(target,key,context) {
        // 注意： target === obj,
        // context === pobj
        console.log( "accessing: ", key );
        return target[key];
    }
},
    { proxy: pobj, revoke: prevoke } =
    Proxy.revocable( obj, handlers );

pobj.a;
// accessing: a
// 1

// 然后：
prevoke();

pobj.a;
// TypeError
```

可取消代理用 Proxy.revocable(..) 创建，这是一个普通函数，而不像 Proxy(..) 一样是构造器。除此之外，它接收同样的两个参数： target 和 handlers。
和 new Proxy(..) 不一样， Proxy.revocable(..) 的返回值不是代理本身。而是一个有两个属性——proxy 和 revode 的对象，我们使用对象解构（参见 2.4 节）把这两个属性分别赋给变量 pobj 和 prevoke()。

一旦可取消代理被取消，任何对它的访问（触发它的任意 trap）都会抛出 TypeError。

**可取消代理的一个可能应用场景是:**

在你的应用中把代理分发到第三方，其中管理你的模型数据，而不是给出真实模型本身的引用。如果你的模型对象改变或者被替换，就可以使分发出去的代理失效，这样第三方能够（通过错误！）知晓变化并请求更新到这个模型的引用。  

### 使用代理  

#### 代理在先， 代理在后  

通常可以把代理看作是对目标对象的“包装”。在这种意义上，代理成为了代码交互的主要对象，而实际目标对象保持隐藏 / 被保护的状态。  

是因为你想要把对象传入到某个无法被完全“信任”的环境，因此需要为对它的访问增强规范性，而不是把对象本身传入。  

考虑：

```javascript
var messages = [],
    handlers = {
        get(target,key) {
            // 字符串值？
            if (typeof target[key] == "string") {
                // 过滤掉标点符号
                return target[key]
                    .replace( /[^\w]/g, "" );
            }
            // 所有其他的传递下去
            return target[key];
        },
        set(target,key,val) {
            // 设定唯一字符串，改为小写
            if (typeof val == "string") {
                val = val.toLowerCase();
                if (target.indexOf( val ) == -1) {
                    target.push(
                        val.toLowerCase()
                    );
                }
            }
            return true;  
        }
    },
    messages_proxy =
        new Proxy( messages, handlers );
// 其他某处：
messages_proxy.push(
	"heLLo...", 42, "wOrlD!!", "WoRld!!"
);
messages_proxy.forEach( function(val){
	console.log(val);
} );
// hello world
messages.forEach( function(val){
	console.log(val);
} );
// hello... world!!
```

我称之为**代理在先**（proxy first）设计，因为我们首先（主要、完全）与代理交互。 

- 通过与 messages_proxy 交互来增加某些特殊的规则，这些是 messages 本身没有的。
- 我们只在值为字符串并且是唯一值的时候才添加这个元素；
- 我们还将这个值变为小写。在从messages_proxy 提取值的时候，我们过滤掉了字符串中的所有标点符号。

另外，我们也可以完全反转这个模式，让目标与代理交流，而不是代理与目标交流。这样，代码只能与主对象交互。这个回退方式的最简单实现就是把 proxy 对象放到主对象的[[Prototype]] 链中。

考虑：

```javascript
var handlers = {
    get(target,key,context) {
        return function() {
        	context.speak(key + "!");
        };
    }
},
catchall = new Proxy( {}, handlers ),
greeter = {
    speak(who = "someone") {
    	console.log( "hello", who );
    }
};

// 设定greeter回退到catchall
Object.setPrototypeOf( greeter, catchall );

greeter.speak(); // hello someone
greeter.speak( "world" ); // hello world

greeter.everyone(); // hello everyone! 
```

这里直接与 greeter 而不是 catchall 交流。当我们调用 speak(..) 的时候，它在 greeter上被找到并直接使用。但是当我们试图访问像 everyone() 这样的方法的时候，这个函数在greeter 上并不存在。

默认的对象属性行为是检查 [[Prototype]] 链，所以会查看 catchall 是否有 everyone 属性。然后代理的 get() 处理函数介入并返回一个用访问的属性名（"everyone"）调用 speak(..) 的函数。

我把这个模式称为**代理在后**（proxy last），因为在这里代理只作为最后的保障。  

#### "No Such Property/Method"  

在你试着访问或设置一个还不存在的属性时，默认情况下对象不是非常具有防御性。你可能希望预先定义好一个对象的所有属性 / 方法之后，访问不存在的属性名时能够抛出一个错误。  

通过代理实现这一点，代理在先或代理在后设计都可以。两种情况我们都考虑一下：  

```javascript
var obj = {
        a: 1,
        foo() {
            console.log( "a:", this.a );
        }
    },
    handlers = {
        get(target,key,context) {
            if (Reflect.has( target, key )) {
                return Reflect.get(
                    target, key, context
                );
            }
            else {
                throw "No such property/method!";
            }
        },
        set(target,key,val,context) {
            if (Reflect.has( target, key )) {
                return Reflect.set(
                    target, key, val, context
                );
            }
            else {
                throw "No such property/method!";
            }
        }
    },
	pobj = new Proxy( obj, handlers );
	
pobj.a = 3;
pobj.foo(); // a: 3  
pobj.b = 4; // Error: No such property/method!
pobj.bar(); // Error: No such property/method!
```

对于 get(..) 和 set(..)，我们都只在目标对象的属性存在的时候才转发这个操作；否则抛
出错误。主对象代码应该与代理对象（pobj）交流，因为它截获这些动作以提供保护。
现在，考虑转换为代理在后设计：

```javascript
var handlers = {
        get() {
            throw "No such property/method!";
        },
        set() {
            throw "No such property/method!";
        }
    },
    pobj = new Proxy( {}, handlers ),
    obj = {
        a: 1,
        foo() {
            console.log( "a:", this.a );
        }
    };
    
// 设定obj回退到pobj
Object.setPrototypeOf( obj, pobj );

obj.a = 3;
obj.foo(); // a: 3

obj.b = 4; // Error: No such property/method!
obj.bar(); // Error: No such property/method!
```

考虑到处理函数的定义方式，这里的代理在后设计更简单一些。与截获 [[Get]] 和 [[Set]]
操作并且只在目标属性存在情况下才转发不同，我们依赖于这样一个事实：如果 [[Get]] 或
[[Set]] 进入我们的 pobj 回退，此时这个动作已经遍历了整个 [[Prototype]] 链并且没有发
现匹配的属性。这时候我们可以自由抛出错误。不错吧？  

#### 代理 hack [[Prototype]] 链  

[[Prototype]] 机制运作的主要通道是 [[Get]] 运算。当直接对象中没有找到一个属性的时候， [[Get]] 会自动把这个运算转给 [[Prototype]] 对象处理。

这意味着你可以使用代理的 get(..) trap 来模拟或扩展这个 [[Prototype]] 机制的概念。

我们将考虑的第一个 hack 就是创建两个对象，通过 [[Prototype]] 连成环状（或者，至少看起来是这样！）。实际上并不能创建一个真正的 [[Prototype]] 环，因为引擎会抛出错误。但是可以用代理模拟！  

考虑：

```javascript
var handlers = {
        get(target,key,context) {
            if (Reflect.has( target, key )) {
                return Reflect.get(
                    target, key, context
                );
            }
            // 伪环状[[Prototype]]
            else {
                return Reflect.get(
                target[
                Symbol.for( "[[Prototype]]" )
                ],
                key,
                context
                );
            }
        }
    },
    obj1 = new Proxy(
        {
            name: "obj-1",
            foo() {
                console.log( "foo:", this.name );
            }
        },
        handlers ),
    },
    obj2 = Object.assign(
        Object.create( obj1 ),
        {
            name: "obj-2",
            bar() {
                console.log( "bar:", this.name );
                this.foo();
            }
        }
    );

// 伪环状[[Prototype]]链接
obj1[ Symbol.for( "[[Prototype]]" ) ] = obj2;

obj1.bar();
// bar: obj-1 <-- 通过代理伪装[[Prototype]]
// foo: obj-1 <-- this上下文依然保留着

obj2.foo();
// foo: obj-2 <-- 通过[[Prototype]]  
```

- 通过 Object.create(..) 语句 obj2 [[Prototype]] 链接到了 obj1。
- 而为了创建反向（环）的链接，我们在 obj1 符号位置 Symbol.for("[[Prototype]]")处创建了属性。
- 代理的 get(..) 处理函数首先查看这个代理上是否有请求的 key。如果没有，就手动把这个运算转发给保存在 target 的 Symbol.for("[[Prototype]]") 位置中的对象引用。
- 这种模式的一个重要优点是， obj1 和 obj2 的定义几乎不会受到在它们之间建立的这种环状关系的影响。所以，这段逻辑可提取出来封装为一个单独的辅助函数，比如setCircularPrototypeOf(..)。

既然已经了解了如何通过 get(..) 来模拟一个 [[Prototype]] 链接，现在让我们来深入hack 一下。不用环状 [[Prototype]]，用多个 [[Prototype]] 链接（也就是“多继承”）怎么样？实际上这非常简单直接：

```javascript
var obj1 = {
        name: "obj-1",
        foo() {
            console.log( "obj1.foo:", this.name );
        },
    },
    obj2 = {
        name: "obj-2",
        foo() {
            console.log( "obj2.foo:", this.name );
        },
        bar() {
            console.log( "obj2.bar:", this.name );
        }
    },
    handlers = {
        get(target,key,context) {
            if (Reflect.has( target, key )) {
                return Reflect.get(
                    target, key, context
                );
            }
            // 伪装多个[[Prototype]]
            else {
                for (var P of target[
                Symbol.for( "[[Prototype]]" )
                ]) {
                    if (Reflect.has( P, key )) {
                        return Reflect.get(
                            P, key, context
                        );  
                    }
                }
            }
        }
    },
    obj3 = new Proxy(
        {
            name: "obj-3",
            baz() {
                this.foo();
                this.bar();
            }
        },
        handlers
    );

// 伪装多个[[Prototype]]链接
obj3[ Symbol.for( "[[Prototype]]" ) ] = [
	obj1, obj2
];

obj3.baz();
// obj1.foo: obj-3
// obj2.bar: obj-3  
```

- obj3 建立了多委托到 obj1 和 obj2。
- 在 obj3.baz() 中， this.foo() 调用最后从 obj1 中提出foo()（先到先得，虽然 obj2 上也有一个 foo()）。
- 如果我们把链接重新排序为 obj2、 obj1，就会找到并使用 obj2.foo()。
- 而现在 this.bar() 调用不会在 obj1 上找到 bar()，所以它会陷入检查 obj2，在其中找到匹配。
- obj1 和 obj2 表示 obj3 的两条平行的 [[Prototype]] 链。 obj1 和 / 或 obj2 本身也可以有普通的 [[Prototype]] 委托到其他对象，或者本身也可以是一个多委托的代理（就像obj3 一样）。
- obj1、 obj2 和 obj3 的定义与通用的处理多委托代理的逻辑几乎是完全分离的。要定义一个像 setPrototypesOf(..)（注意这个表示复数的“s”）这样的工具接收一个主对象和一个对象列表来模拟多 [[Prototype]] 链接是很简单的。 

## Reflect API  

Reflect 对象是一个平凡对象（就像 Math），不像其他内置原生值一样是函数 / 构造器。  

可以使用下面这些工具访问 / 查看一个对象键：

- Reflect.ownKeys(..)
  返回所有“拥有”的（不是“继承”的）键的列表，就像 Object.getOwnPropertyNames(..) 和 Object.getOwnPropertySymbols(..) 返回的一样。关于键的顺序参见后面的“属性排序”一节。
- Reflect.enumerate(..)
  返回一个产生所有（拥有的和“继承的”） 可枚举的（enumerable）非符号键集合的迭代器（参见本系列《你不知道的 JavaScript（上卷）》第二部分）。本质上说，这个键的集合和 foo..in 循环处理的那个键的集合是一样的。关于键的顺序参见后面的“属性排序”一节。
- Reflect.has(..)
  实 质 上 和 in 运 算 符 一 样， 用 于 检 查 某 个 属 性 是 否 在 某 个 对 象 上 或 者 在 它 的[[Prototype]] 链上。比如， Reflect.has(o, "foo") 实质上就是执行 "foo" in o。

函数调用和构造器调用可以通过使用下面这些工具手动执行，与普通的语法（比如， (..)和 new）分开 :  

- Reflect.apply(..)
  举例来说， Reflect.apply(foo,thisObj,[42,"bar"]) 以 thisObj 作为 this 调用 foo(..)函数，传入参数 42 和 "bar"。
- Reflect.construct(..)
  举例来说， Reflect.construct(foo,[42,"bar"]) 实质上就是调用 new foo(42,"bar")。可以使用下面这些工具来手动执行对象属性访问、设置和删除。
- Reflect.get(..)
  举例来说， Reflect.get(o,"foo") 提取 o.foo。
- Reflect.set(..)
  举例来说， Reflect.set(o,"foo",42) 实质上就是执行 o.foo = 42。
- Reflect.deleteProperty(..)
  举例来说， Reflect.deleteProperty(o,"foo") 实质上就是执行 delete o.foo。

Reflect 的元编程能力提供了模拟各种语法特性的编程等价物，把之前隐藏的抽象操作暴
露出来。比如，你可以利用这些能力扩展功能和 API，以实现领域特定语言（DSL）。  

### 属性排序  

#### 在 ES6 之前

一个对象键 / 属性的列出顺序是依赖于具体实现，并未在规范中定义。一般来说，多数引擎按照创建的顺序进行枚举，虽然开发者们一直被强烈建议不要依赖于这个顺序。  

#### 对于 ES6 来说，

拥有属性的列出顺序是由 [[OwnPropertyKeys]] 算法定义的（ES6 规范，9.1.12 节），这个算法产生所有拥有的属性（字符串或符号），不管是否可枚举。这个顺序 只 对 Reflect.ownKeys(..)（ 以 及 扩 展 的 Object.getOwnPropertyNames(..) 和 Object.getOwnPropertySymbols(..)）有保证。

其顺序为：
(1) 首先，按照数字上升排序，枚举所有整数索引拥有的属性；
(2) 然后，按照创建顺序枚举其余的拥有的字符串属性名；
(3) 最后，按照创建顺序枚举拥有的符号属性。  

考虑：

```javascript
var o = {};
o[Symbol("c")] = "yay";  
o[2] = true;
o[1] = true;
o.b = "awesome";
o.a = "cool";
Reflect.ownKeys( o ); // [1,2,"b","a",Symbol(c)]
Object.getOwnPropertyNames( o ); // [1,2,"b","a"]
Object.getOwnPropertySymbols( o ); // [Symbol(c)]  
```

换句话说，所有这 4 种机制（

1. Reflect.enumerate(..)、 
2. Object.keys(..)、
3.  for..in 和 
4. JSON.stringify(..)）

都会匹配同样的与具体实现相关的排序，尽管严格上说是通过不同的路径。  

把这 4 种机制与 [[OwnPropertyKeys]] 的排序匹配的具体实现是允许的，但并不是必须的。尽管如此，你很可能会看到它们的排序特性是这样的：

```javascript
var o = { a: 1, b: 2 };
var p = Object.create( o );
p.c = 3;
p.d = 4;
for (var prop of Reflect.enumerate( p )) {
	console.log( prop );
}
// c d a b
for (var prop in p) {
	console.log( prop );
}
// c d a b
JSON.stringify( p );
// {"c":3,"d":4}
Object.keys( p );
// ["c","d"]
```


总 结 一 下： 对 于 ES6 来 说， Reflect.ownKeys(..)、 Object.getOwnPropertyNames(..) 和Object.getOwnPropertySymbols(..) 的顺序都是可预测且可靠的，这由规范保证。所以依  

## 特性测试  

什么是特性测试？就是一种由你运行的用来判断一个特性是否可用的测试。有时候，这个测试不只是为了测试特性是否存在，还是为了测试特性是否符合指定的行为规范——特性可能存在但却是有问题的。

测试程序的运行环境，然后确定程序行为方式，这是一种元编程技术。  

Function(..) 构造器。
考虑：

```javascript
try {
    new Function( "( () => {} )" );
    ARROW_FUNCS_ENABLED = true;
}
catch (err) {
	ARROW_FUNCS_ENABLED = false;
}  
```

### FeatureTests.io  

## 尾递归调用  

考虑到递归编程的时候（一个函数重复调用自身）——或者两个或多个函数彼此调用形成递归——调用栈的深度很容易达到成百上千，甚至更多。如果内存的使用无限制地增长下去，你可能看到了它将导致的问题。

JavaScript 引擎不得不设置一个武断的限制来防止这种编程技术引起浏览器和设备内存耗尽而崩溃。这也是为什么达到这个限制的时候我们会得到烦人的“RangeError: Maximum call stack size exceeded”。  

有一些称为尾调用（tail call）的函数调用模式  

### 尾调用重写  

考虑：

```javascript
"use strict";
function foo(x) {
    if (x <= 1) return 1;
    return (x / 2) + foo( x - 1 );
}
foo( 123456 ); // RangeError
```

调用 foo(x-1) 不是 PTC，因为它的结果每次在 return 之前要加上 (x / 2)。
但是，要想使这段代码适合 ES6 引擎 TCO，可以这样重写：

```javascript
"use strict";
var foo = (function(){
    function _foo(acc,x) {
        if (x <= 1) return acc;
        return _foo( (x / 2) + acc, x - 1 );
    }
    return function(x) {
        return _foo( 1, x );  
    };
})();
foo( 123456 ); // 3810376848.5  
```

### 非 TCO 优化  

考虑：

```javascript
"use strict";
function trampoline( res ) {
    while (typeof res == "function") {
        res = res();
    }
    return res;
}
var foo = (function(){
    function _foo(acc,x) {
        if (x <= 1) return acc;
            return function partial(){
            return _foo( (x / 2) + acc, x - 1 );
        };
    }
    return function(x) {
        return trampoline( _foo( 1, x ) );
    };
})();
foo( 123456 ); // 3810376848.5
```

这个重写需要最小的改动来把递归转化为 trampoline(..) 中的循环。

- (1) 首先，把 return _foo .. 一行封装在 return partial() { .. 函数表达式中。
- (2) 然后，把 _foo(1,x) 调用封装在 trampoline(..) 调用中。

这 个 技 术 不 限 制 调 用 栈 的 原 因 是， 每 个 内 部 的 partial(..) 函 数 只 是 返 回 到trampoline(..) 的 while 循环中， trampolining 运行函数并进行下一次的循环迭代。换句话说， partial(..) 不会递归调用自身，它只是返回另一个函数。栈深度保持不变，所以可以运行任意长的时间。  

### 元在何处  

TCO 和元编程又有什么关系呢？  

考虑：

```javascript
"use strict";
try {
    (function foo(x){
        if (x < 5E5) return foo( x + 1 );
    })( 1 );
    TCO_ENABLED = true;
}
catch (err) {
	TCO_ENABLED = false;
}
```

在非 TCO 引擎中，递归循环最终会失败，抛出一个异常被 try..catch 捕获。换句话说，
有了 TCO，循环才能完成。  
